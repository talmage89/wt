# Usage Testing Log

Previous test runs archived to `.docs/archive/USAGE-TESTING.log`.

## 2026-02-26T04:20:00Z

Location: ~/wt-usage-tests/2026-02-26T04-20-00/
Tests performed:
- `wt init <remote-url>`: init from a local bare repo used as remote — verified slot summary (5 slots, one on main, four vacant) and shell integration hint printed correctly
- `wt list`: verified tabular output shows slot name, branch, status, pinned flag, and last-used timestamp
- `wt -` (resume command): checked out feature/login then feature/signup; ran `wt -` — correctly navigated to most-recently-used slot (onyx-algae-wood / feature/signup), nav file written to correct path
- Shell integration: `wt shell-init bash` outputs valid `wt()` function; nav file written by binary at `/tmp/wt-nav-<ppid>`; checkout prints "wt: Navigating to <dir>"
- Reconciliation: directly ran `git checkout -b local-only-branch` inside gravel-puffin-wynd slot (bypassing wt); subsequent `wt list` silently updated state to show local-only-branch — no errors, no warnings
Result: PASS

## 2026-02-26T05:30:00Z

Location: ~/wt-usage-tests/2026-02-26T05-30-00/
Tests performed:
- Checkout branch with `/` in name (`feature/auth/oauth`): correctly checked out into slot, branch name displayed accurately in `wt list`, slot directory populated correctly — encoding/decoding of `/` works
- Eviction with full dirty state (staged + unstaged + untracked): filled all 5 slots, created dirty state in main slot (MM README.md + ?? new-untracked.txt), triggered eviction by checking out new branch — eviction stashed dirty state, restore on re-checkout returned all changes including untracked file
- Pin all slots then checkout new branch: pinned all 5 slots, ran `wt checkout -b should-fail-all-pinned` — received clear error "All worktree slots are pinned. Unpin a worktree or increase the slot count to continue." with exit 1, no partial state left
- Slot count increase via config: edited `.wt/config.toml` directly (slot_count 5→7), ran `wt list` — two new vacant slots created immediately (tundra-loam-brisk, lupine-rustic-ruby) with `git worktree add` printed to terminal
- `wt checkout -b` pre-validation: tried `wt checkout -b main` (existing branch) → "wt: Branch 'main' already exists." with exit 1, no eviction; tried `wt checkout -b new-branch nonexistent-sha` → git fatal error with exit 128, no eviction
Result: PASS

## 2026-02-26T06:30:00Z

Location: ~/wt-usage-tests/2026-02-26T06-30-00/
Tests performed:
- Stash commands (list/show/drop + error cases): created dirty state (staged + untracked), triggered eviction, verified `wt stash list` shows entry; `wt stash show <branch>` displays full diff including untracked files; `wt stash show <branch-with-no-stash>` returns "No stash found" with exit 1; `wt stash apply <nonexistent-branch>` returns "No stash found" with exit 1; `wt stash drop <branch>` prompts for confirmation, drops stash on `y`; list shows empty after drop
- `wt checkout --no-restore` + manual apply: evicted branch with dirty state (staged README.md + untracked file), then checked it back out with `--no-restore` — dirty state was NOT restored (clean working tree), stash entry was preserved; `wt stash apply <branch>` then successfully restored all changes; note: staged change is restored as unstaged after apply (standard git behavior without --index, per spec)
- Slot count decrease via config (5→3): edited config directly, ran `wt list` — 2 LRU slots (puffin-hoar-silent/main, clam-spur-dune/br-a) were silently evicted, directories removed, 3 slots remain
- Slot count decrease below pinned count: pinned all 3 remaining slots, decreased slot_count to 2 → error "Cannot reduce slot count to 2: 3 worktrees are pinned. Unpin worktrees first or choose a higher count." with exit 1, no eviction
- Fetch cooldown: first checkout records `last_fetch_at` in state.toml; second checkout within 10 min does NOT update timestamp (fetch skipped); explicit `wt fetch` always runs and updates timestamp; setting `fetch_cooldown_minutes = 0` in config causes every checkout to fetch
Result: PASS

## 2026-02-26T07:30:00Z

Location: ~/wt-usage-tests/2026-02-26T07-30-00/
Tests performed:
- `wt init` twice: second `wt init` on already-initialized container returns "Directory is not empty" with exit 1 — clear error, no corruption
- `wt checkout main` when main already checked out: correctly navigates to existing slot (orbit-sharp-light), prints "Checked out main in orbit-sharp-light", nav file written with correct path — no spurious eviction
- `wt checkout remote-only-branch` (branch exists only on remote): checkout succeeded, git DWIM created local tracking branch — but "Created local branch remote-only-branch from origin/remote-only-branch" message was NOT printed (BUG-029)
Result: BUG FOUND
Bug: BUG-029 — "Created local branch" message missing when remote-only branch checkout succeeds via git DWIM

## 2026-02-26T09:00:00Z

Location: ~/wt-usage-tests/2026-02-26T09-00-00/
Tests performed:
- Symlink shared file creation: configured `directories = ["configs"]`, placed `.wt/shared/configs/app.env`, ran `wt sync` — symlinks created correctly in all 5 slots (`configs/app.env -> ../../.wt/shared/configs/app.env`)
- Git-tracked file takes precedence over symlink: created `feature/gamma` branch with `configs/app.env` as a git-tracked file; `wt checkout feature/gamma` removed the pre-existing symlink (via `removeSymlinks` step 9), git placed the tracked file, then `establishSymlinks` detected the file was tracked and skipped creating the symlink (printed "Skipping symlink for configs/app.env: file is tracked by git in branch feature/gamma.") — result: slot has the branch-specific tracked file, not the shared symlink
- Template expansion: configured `[[templates]]` with `source = "build.sh.template"`, `target = "build.sh"`, variables `{{BRANCH_NAME}}` and `{{WORKTREE_DIR}}`; `wt sync` generated `build.sh` correctly in all slots with branch-specific values; vacant slot gets empty `{{BRANCH_NAME}}`
- Reconciliation with deleted slot dir: manually `rm -rf bolt-mild-lucid`; ran `wt list` — reconcile detected missing slot, silently ran `git worktree add` to create a new slot (`newt-flume-larch`), maintaining the configured 5-slot count; no crash, clean output
- Broken symlink cleanup: deleted canonical `.wt/shared/configs/app.env` file; ran `wt sync` — all broken symlinks in all slots were removed correctly
Result: PASS

## 2026-02-26T10:00:00Z

Location: ~/wt-usage-tests/2026-02-26T10-00-00/
Tests performed:
- Stash archival lifecycle: created dirty state on `will-be-deleted`, evicted to create stash, faked `last_used_at` to 8 days ago in stash metadata, deleted remote branch from bare repo, ran `wt fetch` — stash archived correctly ("Archived 1 stash(es): will-be-deleted"), patch file written to `.wt/stashes/archive/will-be-deleted.patch` containing full diff including untracked files; note: zstd not available so patch stored uncompressed (expected "Warning: zstd not found. Archived stash stored uncompressed.")
- Drop archived stash: ran `wt stash list` — showed entry with status "archived"; `wt stash drop will-be-deleted` with confirmation → "Stash dropped for 'will-be-deleted'"; archive patch file deleted from disk; `wt stash list` showed "No saved stashes." — full archived stash lifecycle verified
- Corrupt state.toml: wrote invalid TOML (`%CORRUPTED TOML%\n[[[bad section\nkey =`) to `.wt/state.toml`; ran `wt list` — printed "Warning: .wt/state.toml is corrupted. Regenerating from git state." to stderr, then successfully regenerated all 5 slots from git worktree list with epoch timestamps (20510d ago), clean exit code 0 — graceful recovery confirmed
- Manual `git worktree add` in container: ran `git --git-dir=.wt/repo worktree add ./manual-worktree -b manual-branch` directly (bypassing wt); ran `wt list` — reconcile discovered `manual-worktree` as a new slot and added it to state; but because slot count in config is 5 and there were now 6 slots (5 original + manual), `adjustSlotCount` LRU-evicted one original slot (`arch-short-wynd`, branch-a) since all had epoch timestamps from the prior state corruption recovery; `manual-worktree` (manual-branch) appeared in the list as a managed slot — adoption of external worktrees works, slot count enforcement is immediate
Result: PASS

## 2026-02-26T11:00:00Z

Location: ~/wt-usage-tests/2026-02-26T11-00-00/
Tests performed:
- Post-checkout hook (VISION §4.3): created `.wt/hooks/post-checkout` (executable) that writes `HOOK_FIRED: path=<dir> branch=<branch>` to a log file; sourced shell integration, ran `wt checkout feature/hook-test2` via the shell function — hook fired correctly with `$1` = absolute worktree path and `$2` = branch name; shell cd'd to slot, then hook executed in correct order
- `wt clean` command (VISION §5.5): created stash, faked `created_at`/`last_used_at` to 8 days ago, deleted remote branch, ran `wt fetch` — stash archived; ran `wt clean` with no input → "Aborted." gracefully; with input "1" (select stash) → showed "Delete 1 stash? [y/N]" confirmation; with input "1\ny" → "Deleted 1 archived stash.", patch file removed, `wt stash list` shows "No saved stashes."
- Stash restore with conflicts (VISION §5.2, §15.2): created stash at commit e9de83f with `conflict-file.txt` modifications; then advanced local branch to a new commit (3d90e0a) where `conflict-file.txt` has conflicting content; re-checkout triggered stash apply failure — wt printed "wt: Stash for conflict-test produced conflicts. Resolve manually." and "wt: Run 'wt stash drop conflict-test' after resolution, or 'wt stash show conflict-test' to inspect."; checkout succeeded (exit 0), conflict markers visible in working tree, stash retained (not deleted) — correct per spec
- `wt init` from inside existing repo (VISION §2.1): created plain git repo with README.md and one commit; ran `wt init` (no URL) from inside — `.git/` moved to `.wt/repo/`, 5 worktree slots created, active slot (`wide-pearl-ridge`) has `main` checked out with README.md; container root has no `.git` and no working files (correct); shell integration hint printed
Result: PASS

## 2026-02-26T12:00:00Z

Location: ~/wt-usage-tests/2026-02-26T12-00-00/
Tests performed:
- `wt init <url>` into non-empty non-git directory (VISION §15.1): created dir with single dotfile `.envrc`, ran `wt init <url>` — correctly failed with "Directory is not empty. Use 'wt init' from inside an existing repository, or run from an empty directory." (exit 1), no partial state left
- Evict all slots in sequence — stash accumulation (VISION §5.1): checked out 5 branches filling all slots, dirtied each with staged + untracked files, then triggered 5 sequential evictions via new checkouts — all 5 stash metadata TOML files accumulated in `.wt/stashes/`; `wt stash list` showed all 5 entries; re-checkout of branch-1 correctly restored staged and untracked files (newly-staged files restore as staged, consistent with git stash apply behavior)
- `wt -` from container directory vs. outside container (VISION §9, Phase 1 §1.9): from container root (outside any slot), `wt -` navigated to MRU slot correctly; from unrelated directory (`/tmp`), `wt -` correctly failed with "Not inside a wt-managed container." (exit 1) — expected since no container to infer
- Modify template source + `wt sync` regenerates all slots (VISION §7.4): created `templates/app.env` with `{{BRANCH_NAME}}` and `{{WORKTREE_DIR}}` variables, configured in `.wt/config.toml`; `wt sync` generated `.env` in all 5 slots; modified template source (changed APP_ENV and added DB_HOST); second `wt sync` regenerated all 5 `.env` files with new content — all slots updated correctly
- Unpin and immediately evict (VISION §11): pinned MRU slot, dirtied it, then unpinned; subsequent checkouts drove LRU selection; when slot finally became LRU candidate it was evicted with "dirty state stashed" message; `wt stash list` confirmed stash entry created for the formerly-pinned branch — pin removal correctly restores LRU eligibility
Result: PASS

## 2026-02-26T13:00:00Z

Location: ~/wt-usage-tests/2026-02-26T13-00-00/
Tests performed:
- BUG-029 fix verification (`wt checkout remote-only-feature`): set up a bare remote with `remote-only-feature` pushed only to remote; ran `wt init <remote>` then `wt checkout remote-only-feature` — checkout succeeded and git DWIM created a local tracking branch ("Switched to branch 'remote-only-feature'"), but the "wt: Created local branch remote-only-feature from origin/remote-only-feature" message was STILL NOT PRINTED — BUG-029 fix is ineffective. Root cause: `git clone --bare` creates `refs/heads/*` for ALL remote branches, so `git.refExists(repoDir, 'refs/heads/remote-only-feature')` returns `true` even for "remote-only" branches, causing `localBranchExistedBefore = true` and suppressing the message. The fix must use `branch_history` instead of `refExists` to detect first-time checkout.
Result: BUG FOUND
Bug: BUG-029 (re-opened) — BUG-029 fix ineffective: bare clone creates refs/heads/* for all remote branches, making localBranchExistedBefore always true

## 2026-02-26T15:00:00Z

Location: ~/wt-usage-tests/2026-02-26T15-00-00/
Tests performed:
- BUG-029 fix verification (`branch_history` approach): set up bare remote with `main` and `remote-only-feature` pushed; ran `wt init <remote>` then `wt checkout remote-only-feature` — `remote-only-feature` was absent from `branch_history` so `localBranchExistedBefore = false`; checkout succeeded and printed "wt: Created local branch remote-only-feature from origin/remote-only-feature" correctly; re-checkout of the same branch did NOT print the message (branch already in `branch_history`) — BUG-029 fix confirmed working
- Archived stash auto-restore warning (VISION §5.2, §10): created branch with staged + untracked dirty state, evicted it to create stash, faked `last_used_at` to 8 days ago, ran `wt fetch` to archive stash; re-checkout of the branch printed "wt: Archived stash for stash-archive-test was not auto-restored. View with 'wt stash show stash-archive-test'." before the checkout feedback line — correct per spec; archived stash is not deleted on checkout
- `wt checkout -b <branch> <explicit-start-point>` (VISION §3.3): tested `wt checkout -b explicit-start-test <full-SHA>` → "wt: Created branch explicit-start-test from <sha>"; tested `wt checkout -b from-origin-main origin/main` → "wt: Created branch from-origin-main from origin/main" — both start-point forms work correctly; pre-validation rejects invalid refs before eviction
- Re-stash (second eviction of same branch, VISION §5.1): evicted branch creating stash A (ref 8aaf604); re-checked-out restoring stash A (stash consumed); created new dirty state (additional changes on top of restored state); evicted branch again creating stash B (ref 615416c, different from A); `wt stash show` confirmed stash B contains accumulated dirty state from both rounds (first + second changes + both untracked files) — second eviction correctly replaces the consumed stash ref with a fresh one; no stash loss since first stash was properly restored before second eviction
Result: PASS
