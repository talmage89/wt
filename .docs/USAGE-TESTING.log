# Usage Testing Log

Previous test runs archived to `.docs/archive/USAGE-TESTING.log`.

## 2026-02-26T04:20:00Z

Location: ~/wt-usage-tests/2026-02-26T04-20-00/
Tests performed:
- `wt init <remote-url>`: init from a local bare repo used as remote — verified slot summary (5 slots, one on main, four vacant) and shell integration hint printed correctly
- `wt list`: verified tabular output shows slot name, branch, status, pinned flag, and last-used timestamp
- `wt -` (resume command): checked out feature/login then feature/signup; ran `wt -` — correctly navigated to most-recently-used slot (onyx-algae-wood / feature/signup), nav file written to correct path
- Shell integration: `wt shell-init bash` outputs valid `wt()` function; nav file written by binary at `/tmp/wt-nav-<ppid>`; checkout prints "wt: Navigating to <dir>"
- Reconciliation: directly ran `git checkout -b local-only-branch` inside gravel-puffin-wynd slot (bypassing wt); subsequent `wt list` silently updated state to show local-only-branch — no errors, no warnings
Result: PASS

## 2026-02-26T05:30:00Z

Location: ~/wt-usage-tests/2026-02-26T05-30-00/
Tests performed:
- Checkout branch with `/` in name (`feature/auth/oauth`): correctly checked out into slot, branch name displayed accurately in `wt list`, slot directory populated correctly — encoding/decoding of `/` works
- Eviction with full dirty state (staged + unstaged + untracked): filled all 5 slots, created dirty state in main slot (MM README.md + ?? new-untracked.txt), triggered eviction by checking out new branch — eviction stashed dirty state, restore on re-checkout returned all changes including untracked file
- Pin all slots then checkout new branch: pinned all 5 slots, ran `wt checkout -b should-fail-all-pinned` — received clear error "All worktree slots are pinned. Unpin a worktree or increase the slot count to continue." with exit 1, no partial state left
- Slot count increase via config: edited `.wt/config.toml` directly (slot_count 5→7), ran `wt list` — two new vacant slots created immediately (tundra-loam-brisk, lupine-rustic-ruby) with `git worktree add` printed to terminal
- `wt checkout -b` pre-validation: tried `wt checkout -b main` (existing branch) → "wt: Branch 'main' already exists." with exit 1, no eviction; tried `wt checkout -b new-branch nonexistent-sha` → git fatal error with exit 128, no eviction
Result: PASS

## 2026-02-26T06:30:00Z

Location: ~/wt-usage-tests/2026-02-26T06-30-00/
Tests performed:
- Stash commands (list/show/drop + error cases): created dirty state (staged + untracked), triggered eviction, verified `wt stash list` shows entry; `wt stash show <branch>` displays full diff including untracked files; `wt stash show <branch-with-no-stash>` returns "No stash found" with exit 1; `wt stash apply <nonexistent-branch>` returns "No stash found" with exit 1; `wt stash drop <branch>` prompts for confirmation, drops stash on `y`; list shows empty after drop
- `wt checkout --no-restore` + manual apply: evicted branch with dirty state (staged README.md + untracked file), then checked it back out with `--no-restore` — dirty state was NOT restored (clean working tree), stash entry was preserved; `wt stash apply <branch>` then successfully restored all changes; note: staged change is restored as unstaged after apply (standard git behavior without --index, per spec)
- Slot count decrease via config (5→3): edited config directly, ran `wt list` — 2 LRU slots (puffin-hoar-silent/main, clam-spur-dune/br-a) were silently evicted, directories removed, 3 slots remain
- Slot count decrease below pinned count: pinned all 3 remaining slots, decreased slot_count to 2 → error "Cannot reduce slot count to 2: 3 worktrees are pinned. Unpin worktrees first or choose a higher count." with exit 1, no eviction
- Fetch cooldown: first checkout records `last_fetch_at` in state.toml; second checkout within 10 min does NOT update timestamp (fetch skipped); explicit `wt fetch` always runs and updates timestamp; setting `fetch_cooldown_minutes = 0` in config causes every checkout to fetch
Result: PASS

## 2026-02-26T07:30:00Z

Location: ~/wt-usage-tests/2026-02-26T07-30-00/
Tests performed:
- `wt init` twice: second `wt init` on already-initialized container returns "Directory is not empty" with exit 1 — clear error, no corruption
- `wt checkout main` when main already checked out: correctly navigates to existing slot (orbit-sharp-light), prints "Checked out main in orbit-sharp-light", nav file written with correct path — no spurious eviction
- `wt checkout remote-only-branch` (branch exists only on remote): checkout succeeded, git DWIM created local tracking branch — but "Created local branch remote-only-branch from origin/remote-only-branch" message was NOT printed (BUG-029)
Result: BUG FOUND
Bug: BUG-029 — "Created local branch" message missing when remote-only branch checkout succeeds via git DWIM

## 2026-02-26T09:00:00Z

Location: ~/wt-usage-tests/2026-02-26T09-00-00/
Tests performed:
- Symlink shared file creation: configured `directories = ["configs"]`, placed `.wt/shared/configs/app.env`, ran `wt sync` — symlinks created correctly in all 5 slots (`configs/app.env -> ../../.wt/shared/configs/app.env`)
- Git-tracked file takes precedence over symlink: created `feature/gamma` branch with `configs/app.env` as a git-tracked file; `wt checkout feature/gamma` removed the pre-existing symlink (via `removeSymlinks` step 9), git placed the tracked file, then `establishSymlinks` detected the file was tracked and skipped creating the symlink (printed "Skipping symlink for configs/app.env: file is tracked by git in branch feature/gamma.") — result: slot has the branch-specific tracked file, not the shared symlink
- Template expansion: configured `[[templates]]` with `source = "build.sh.template"`, `target = "build.sh"`, variables `{{BRANCH_NAME}}` and `{{WORKTREE_DIR}}`; `wt sync` generated `build.sh` correctly in all slots with branch-specific values; vacant slot gets empty `{{BRANCH_NAME}}`
- Reconciliation with deleted slot dir: manually `rm -rf bolt-mild-lucid`; ran `wt list` — reconcile detected missing slot, silently ran `git worktree add` to create a new slot (`newt-flume-larch`), maintaining the configured 5-slot count; no crash, clean output
- Broken symlink cleanup: deleted canonical `.wt/shared/configs/app.env` file; ran `wt sync` — all broken symlinks in all slots were removed correctly
Result: PASS

## 2026-02-26T10:00:00Z

Location: ~/wt-usage-tests/2026-02-26T10-00-00/
Tests performed:
- Stash archival lifecycle: created dirty state on `will-be-deleted`, evicted to create stash, faked `last_used_at` to 8 days ago in stash metadata, deleted remote branch from bare repo, ran `wt fetch` — stash archived correctly ("Archived 1 stash(es): will-be-deleted"), patch file written to `.wt/stashes/archive/will-be-deleted.patch` containing full diff including untracked files; note: zstd not available so patch stored uncompressed (expected "Warning: zstd not found. Archived stash stored uncompressed.")
- Drop archived stash: ran `wt stash list` — showed entry with status "archived"; `wt stash drop will-be-deleted` with confirmation → "Stash dropped for 'will-be-deleted'"; archive patch file deleted from disk; `wt stash list` showed "No saved stashes." — full archived stash lifecycle verified
- Corrupt state.toml: wrote invalid TOML (`%CORRUPTED TOML%\n[[[bad section\nkey =`) to `.wt/state.toml`; ran `wt list` — printed "Warning: .wt/state.toml is corrupted. Regenerating from git state." to stderr, then successfully regenerated all 5 slots from git worktree list with epoch timestamps (20510d ago), clean exit code 0 — graceful recovery confirmed
- Manual `git worktree add` in container: ran `git --git-dir=.wt/repo worktree add ./manual-worktree -b manual-branch` directly (bypassing wt); ran `wt list` — reconcile discovered `manual-worktree` as a new slot and added it to state; but because slot count in config is 5 and there were now 6 slots (5 original + manual), `adjustSlotCount` LRU-evicted one original slot (`arch-short-wynd`, branch-a) since all had epoch timestamps from the prior state corruption recovery; `manual-worktree` (manual-branch) appeared in the list as a managed slot — adoption of external worktrees works, slot count enforcement is immediate
Result: PASS

## 2026-02-26T11:00:00Z

Location: ~/wt-usage-tests/2026-02-26T11-00-00/
Tests performed:
- Post-checkout hook (VISION §4.3): created `.wt/hooks/post-checkout` (executable) that writes `HOOK_FIRED: path=<dir> branch=<branch>` to a log file; sourced shell integration, ran `wt checkout feature/hook-test2` via the shell function — hook fired correctly with `$1` = absolute worktree path and `$2` = branch name; shell cd'd to slot, then hook executed in correct order
- `wt clean` command (VISION §5.5): created stash, faked `created_at`/`last_used_at` to 8 days ago, deleted remote branch, ran `wt fetch` — stash archived; ran `wt clean` with no input → "Aborted." gracefully; with input "1" (select stash) → showed "Delete 1 stash? [y/N]" confirmation; with input "1\ny" → "Deleted 1 archived stash.", patch file removed, `wt stash list` shows "No saved stashes."
- Stash restore with conflicts (VISION §5.2, §15.2): created stash at commit e9de83f with `conflict-file.txt` modifications; then advanced local branch to a new commit (3d90e0a) where `conflict-file.txt` has conflicting content; re-checkout triggered stash apply failure — wt printed "wt: Stash for conflict-test produced conflicts. Resolve manually." and "wt: Run 'wt stash drop conflict-test' after resolution, or 'wt stash show conflict-test' to inspect."; checkout succeeded (exit 0), conflict markers visible in working tree, stash retained (not deleted) — correct per spec
- `wt init` from inside existing repo (VISION §2.1): created plain git repo with README.md and one commit; ran `wt init` (no URL) from inside — `.git/` moved to `.wt/repo/`, 5 worktree slots created, active slot (`wide-pearl-ridge`) has `main` checked out with README.md; container root has no `.git` and no working files (correct); shell integration hint printed
Result: PASS

## 2026-02-26T12:00:00Z

Location: ~/wt-usage-tests/2026-02-26T12-00-00/
Tests performed:
- `wt init <url>` into non-empty non-git directory (VISION §15.1): created dir with single dotfile `.envrc`, ran `wt init <url>` — correctly failed with "Directory is not empty. Use 'wt init' from inside an existing repository, or run from an empty directory." (exit 1), no partial state left
- Evict all slots in sequence — stash accumulation (VISION §5.1): checked out 5 branches filling all slots, dirtied each with staged + untracked files, then triggered 5 sequential evictions via new checkouts — all 5 stash metadata TOML files accumulated in `.wt/stashes/`; `wt stash list` showed all 5 entries; re-checkout of branch-1 correctly restored staged and untracked files (newly-staged files restore as staged, consistent with git stash apply behavior)
- `wt -` from container directory vs. outside container (VISION §9, Phase 1 §1.9): from container root (outside any slot), `wt -` navigated to MRU slot correctly; from unrelated directory (`/tmp`), `wt -` correctly failed with "Not inside a wt-managed container." (exit 1) — expected since no container to infer
- Modify template source + `wt sync` regenerates all slots (VISION §7.4): created `templates/app.env` with `{{BRANCH_NAME}}` and `{{WORKTREE_DIR}}` variables, configured in `.wt/config.toml`; `wt sync` generated `.env` in all 5 slots; modified template source (changed APP_ENV and added DB_HOST); second `wt sync` regenerated all 5 `.env` files with new content — all slots updated correctly
- Unpin and immediately evict (VISION §11): pinned MRU slot, dirtied it, then unpinned; subsequent checkouts drove LRU selection; when slot finally became LRU candidate it was evicted with "dirty state stashed" message; `wt stash list` confirmed stash entry created for the formerly-pinned branch — pin removal correctly restores LRU eligibility
Result: PASS

## 2026-02-26T13:00:00Z

Location: ~/wt-usage-tests/2026-02-26T13-00-00/
Tests performed:
- BUG-029 fix verification (`wt checkout remote-only-feature`): set up a bare remote with `remote-only-feature` pushed only to remote; ran `wt init <remote>` then `wt checkout remote-only-feature` — checkout succeeded and git DWIM created a local tracking branch ("Switched to branch 'remote-only-feature'"), but the "wt: Created local branch remote-only-feature from origin/remote-only-feature" message was STILL NOT PRINTED — BUG-029 fix is ineffective. Root cause: `git clone --bare` creates `refs/heads/*` for ALL remote branches, so `git.refExists(repoDir, 'refs/heads/remote-only-feature')` returns `true` even for "remote-only" branches, causing `localBranchExistedBefore = true` and suppressing the message. The fix must use `branch_history` instead of `refExists` to detect first-time checkout.
Result: BUG FOUND
Bug: BUG-029 (re-opened) — BUG-029 fix ineffective: bare clone creates refs/heads/* for all remote branches, making localBranchExistedBefore always true

## 2026-02-26T15:00:00Z

Location: ~/wt-usage-tests/2026-02-26T15-00-00/
Tests performed:
- BUG-029 fix verification (`branch_history` approach): set up bare remote with `main` and `remote-only-feature` pushed; ran `wt init <remote>` then `wt checkout remote-only-feature` — `remote-only-feature` was absent from `branch_history` so `localBranchExistedBefore = false`; checkout succeeded and printed "wt: Created local branch remote-only-feature from origin/remote-only-feature" correctly; re-checkout of the same branch did NOT print the message (branch already in `branch_history`) — BUG-029 fix confirmed working
- Archived stash auto-restore warning (VISION §5.2, §10): created branch with staged + untracked dirty state, evicted it to create stash, faked `last_used_at` to 8 days ago, ran `wt fetch` to archive stash; re-checkout of the branch printed "wt: Archived stash for stash-archive-test was not auto-restored. View with 'wt stash show stash-archive-test'." before the checkout feedback line — correct per spec; archived stash is not deleted on checkout
- `wt checkout -b <branch> <explicit-start-point>` (VISION §3.3): tested `wt checkout -b explicit-start-test <full-SHA>` → "wt: Created branch explicit-start-test from <sha>"; tested `wt checkout -b from-origin-main origin/main` → "wt: Created branch from-origin-main from origin/main" — both start-point forms work correctly; pre-validation rejects invalid refs before eviction
- Re-stash (second eviction of same branch, VISION §5.1): evicted branch creating stash A (ref 8aaf604); re-checked-out restoring stash A (stash consumed); created new dirty state (additional changes on top of restored state); evicted branch again creating stash B (ref 615416c, different from A); `wt stash show` confirmed stash B contains accumulated dirty state from both rounds (first + second changes + both untracked files) — second eviction correctly replaces the consumed stash ref with a fresh one; no stash loss since first stash was properly restored before second eviction
Result: PASS

## 2026-02-26T16:00:00Z

Location: ~/wt-usage-tests/2026-02-26T16-00-00/
Tests performed:
- `wt co` and `wt ls` aliases (VISION §9): ran `wt ls` from container root — correct tabular output with slot, branch, status, pinned, last-used columns; ran `wt co feature/foo` — correct checkout with "wt: Created local branch feature/foo from origin/feature/foo" (BUG-029 fix re-confirmed: feature/foo not in branch_history, so message appears); both aliases function identically to their full-name counterparts
- `wt pin <slot-name>` and `wt unpin <slot-name>` by explicit slot name from outside the worktree (VISION §11): pinned `stoat-sharp-meadow` from container root — "Pinned 'stoat-sharp-meadow' (branch: main). It will not be evicted."; `wt ls` showed `pinned` flag; unpinned — "Unpinned 'stoat-sharp-meadow' (branch: main). It can now be evicted via LRU."; pin flag cleared — both commands work by slot name from any directory within the container
- `wt stash apply` with no branch arg (VISION §5.2.1): created stash for `feature/foo` via eviction; re-checked it out with `--no-restore`; ran `wt stash apply` from within the slot with no argument — correctly defaulted to current branch `feature/foo`, applied stash ("Stash applied and cleaned up for 'feature/foo'."), restored modified `foo.txt` and untracked `untracked.txt`; staged change restored as unstaged (standard git behavior)
- `wt stash drop` with no branch arg (VISION §5.2.1): created stash for `br-c` via eviction; re-checked out `br-c` with `--no-restore`; ran `wt stash drop` from within the slot with no argument — correctly defaulted to current branch `br-c`, prompted "Drop stash for 'br-c'? This cannot be undone. [y/N]"; confirmed with `y` → "Stash dropped for 'br-c'."; `wt stash list` showed "No saved stashes." — no-arg form works correctly
- `wt` with no args outside managed container (VISION §8): ran from `/tmp` — printed full CLI help listing all commands with descriptions and aliases; exit code 0 — correct behavior per spec ("display help/usage" when not inside managed container)
- Container discovery from deeply nested subdirectory (VISION §1, implicit): created `stoat-sharp-meadow/src/components/ui/buttons/`; ran `wt ls`, `wt stash list`, and `wt checkout main` from within — all correctly found the container by walking up the directory tree; `wt checkout main` navigated to `peat-gull-vivid` (already had main) without eviction — container discovery via parent-walk works at arbitrary depth
Result: PASS

## 2026-02-26T17:00:00Z

Location: ~/wt-usage-tests/2026-02-26T17-00-00/
Tests performed:
- `wt pin` / `wt unpin` with no arg from within a worktree (VISION §11): from within `hart-ember-pitch` (branch: main), ran `wt pin` with no argument — correctly auto-detected current slot, printed "Pinned 'hart-ember-pitch' (branch: main). It will not be evicted.", pin flag visible in `wt list`; `wt unpin` (no arg) correctly cleared pin flag — both commands auto-detect slot from cwd when no argument given
- `wt stash show` with no arg (VISION §5.2.1): checked out `br-b` with `--no-restore` (stash retained); from within `br-b`'s slot ran `wt stash show` (no arg) — defaulted to current branch `br-b`, displayed full stash diff including staged file and untracked file, exit 0; also tested error case: from main's slot after stash auto-restored, `wt stash show` (no arg) returned "No stash found for branch 'main'" with exit 0 — both cases correct
- `wt shell-init zsh` (VISION §4.1): output is syntactically valid (bash -n check passes); exports `WT_SHELL_INTEGRATION=1`; defines `wt()` function; includes nav file mechanism (`/tmp/wt-nav-$$`) and post-checkout hook execution; output is identical to bash shell-init (POSIX-compatible, valid for zsh)
- Clean eviction — no dirty state → no stash created (VISION §5.1): evicted `br-d` (clean slot) by checking out `br-g`; eviction message "wt: Evicted br-d from brisk-pool-snipe" had NO "(dirty state stashed)" suffix; stash list unchanged (no new entry for br-d); VISION §5.1 requirement "If the worktree has no dirty state, no stash is created" confirmed
- `wt sync` with no shared dirs or templates configured (VISION §6.4): config has `directories = []` and no `[[templates]]` entries; ran `wt sync` — completed cleanly with no output, exit 0; no stray files created in `.wt/shared/` or `.wt/templates/` — graceful no-op confirmed
Result: PASS

## 2026-02-26T18:00:00Z

Location: ~/wt-usage-tests/2026-02-26T18-00-00/
Tests performed:
- `wt stash apply <branch>` where branch is not in any slot (PHASE-2 checklist): created stash for `feature/alpha` via eviction; then checked out 5 other branches so feature/alpha had no slot; ran `wt stash apply feature/alpha` from container root — "wt: Branch 'feature/alpha' is not checked out in any slot. Run 'wt checkout feature/alpha' first." (exit 1); same error from within a different slot — consistent error messaging, no crash
- Template `{{BRANCH_NAME}}` on vacant (detached) slot (PHASE-2 checklist): created template with `source = "templates/info.txt"`, `target = "info.txt"` containing `SLOT={{WORKTREE_DIR}}` and `BRANCH={{BRANCH_NAME}}`; fresh container with 1 active slot (main) and 4 vacant; ran `wt sync` — active slot got `BRANCH=main`, all 4 vacant slots got `BRANCH=` (empty string); `{{WORKTREE_DIR}}` correctly expanded to slot name in all cases — empty string for BRANCH_NAME on detached slots is correct per PLAN.md
- Nav file written and cleaned up by shell function (PHASE-2 checklist): defined `wt()` wrapper around `node /workspace/bin/wt.mjs` with nav file cleanup logic; ran `wt checkout feature/alpha` through the function — binary wrote `/tmp/wt-nav-<shell-PID>` containing the target slot path; function read it, deleted it, and cded to target; after function completed, `/tmp/wt-nav-$$` was absent (confirmed "PASS: Nav file written and cleaned up by shell function"); "wt: Navigating to /path/..." printed as expected when `WT_SHELL_INTEGRATION=1`
- `wt -` from fresh container (VISION Phase 1 §1.9): `wt init` followed by `wt -` (no prior checkout beyond init) — correctly navigated to the only active slot (main in late-great-inert), printed "wt: Resuming main in late-great-inert" with exit 0; `wt -` when already at MRU slot — printed "wt: Already in the most recently used worktree (feature/alpha in peak-bur-thin)" with exit 0, no nav file written — correct no-op behavior per spec
- `wt clean` with no archived stashes (VISION §5.5): container had one active stash (br-e, status=active); ran `wt clean` with no input — printed "No archived stashes to clean." with exit 0; the active stash was not touched; correct per spec ("Interactive prompt listing archived stashes" — nothing to list means clean exit)
Result: PASS

## 2026-02-26T19:00:00Z

Location: ~/wt-usage-tests/2026-02-26T19-00-00/
Tests performed:
- `wt checkout <nonexistent-branch>` (not local, not remote, VISION §15.3): attempted `wt checkout totally-nonexistent-branch-xyz` in a fresh container — printed "wt: Branch 'totally-nonexistent-branch-xyz' not found locally or on remote." (exit 1); no state mutation, all 5 slots unchanged; pre-validation fires before any eviction attempt — correct per BUG-028 fix / VISION §15.3
- `wt init` from a dirty repo with staged + untracked files (VISION §2.1): repo had staged `README.md` modification + untracked `untracked-file.txt`; `wt init` succeeded — `.git/` moved to `.wt/repo/`, 5 slots created, active slot (`luna-flock-spar`) showed dirty status in `wt list`; `git status` in slot confirmed untracked file preserved and modified content preserved; note: staged change becomes unstaged after init (standard git behavior when moving the .git dir and creating a worktree — the index transfers but worktree checkout is fresh); actual file content was not lost
- `wt stash list` / `wt stash show` / `wt stash apply` immediately after fresh init with zero stashes (VISION §5.2.1): no stash dir exists; `wt stash list` returned "No saved stashes." (exit 0); `wt stash show main` returned "wt: No stash found for branch 'main'." (exit 1); `wt stash apply main` returned "wt: No stash found for branch 'main'." (exit 1); no crash, graceful empty state handling
- `wt sync` real-file migration (VISION §6.4): configured `directories = ["configs"]`; created real (non-symlink, not git-tracked) files `app.env` and `extra.conf` in the active slot's `configs/` directory; ran `wt sync` — files migrated to `.wt/shared/configs/`; original files replaced with symlinks (`app.env -> ../../.wt/shared/configs/app.env`); content preserved correctly; vacant slot (`spur-steel-glen`) also got symlinks created — full migration + propagation confirmed
- `wt fetch` standalone command (VISION §12): first `wt fetch` when `last_fetch_at` not set — ran successfully, printed "Fetched latest from remote.", set `last_fetch_at` in state.toml; `wt checkout` within cooldown did not update timestamp (skipped fetch silently); second `wt fetch` always ran and updated timestamp (bypasses cooldown as expected); pushed new branch `test-fetch-branch` to remote, ran `wt fetch` — fetched new branch refs; subsequent `wt checkout test-fetch-branch` succeeded with "Created local branch test-fetch-branch from origin/test-fetch-branch" message — fetch-then-checkout roundtrip confirmed
Result: PASS

## 2026-02-26T20:00:00Z

Location: ~/wt-usage-tests/2026-02-26T20-00-00/
Tests performed:
- `wt shell-init fish` (VISION §4.1): output defines `function wt` with fish syntax; `set -gx WT_SHELL_INTEGRATION 1` exports the env var; nav file path uses `$fish_pid` (matches `process.ppid` in the binary when fish spawns the wt subprocess); includes nav file cleanup, `cd $target_dir`, post-checkout hook execution, and `return $exit_code` — all structural elements present and syntactically valid fish; parallel structure to bash/zsh versions confirmed
- `wt checkout` from within the LRU slot (evicting yourself, VISION §3.1): filled all 5 slots; from within `wombat-oriole-bent` (main, LRU, dirty state), ran `wt checkout feature/epsilon` — wt correctly identified and evicted `wombat-oriole-bent` as the LRU slot (printing "wt: Evicted main from wombat-oriole-bent (dirty state stashed)"), checked out `feature/epsilon` there, nav file written pointing back to the same directory; stash for `main` created and visible in `wt stash list`; no crash, correct behavior when the eviction target is your current working directory
- `wt stash show <branch>` on archived stash (VISION §5.2.1): created dirty state (staged + untracked), evicted to create stash, faked `last_used_at` to 8 days ago, deleted remote branch, ran `wt fetch` — stash archived to `feature--alpha.patch`; ran `wt stash show feature/alpha` on the archived stash — correctly read patch file and displayed full diff (staged change to alpha.txt + untracked file untracked-in-alpha.txt), exit 0; `wt stash show` on archived stash reads from the patch file correctly
- `wt init` from repo with no remote, then `wt checkout` of manually-created local branch (VISION §2.1, §3.2): initialized wt from a local-only git repo (no remote); init succeeded with 5 slots; then manually created a local branch via `git --git-dir=.wt/repo branch feature/local-only main`; ran `wt checkout feature/local-only` — checkout succeeded, but printed "wt: Created local branch feature/local-only from origin/feature/local-only" — INCORRECT: there is no remote and `origin/feature/local-only` does not exist; branch was a locally-created branch, not from a remote; the BUG-029 fix uses `branch_history` as proxy for "first time checkout = created from remote" which incorrectly fires for local-only branches (BUG-030)
Result: BUG FOUND
Bug: BUG-030 — "Created local branch from origin/X" message appears incorrectly for manually-created local branches and no-remote repos

## 2026-02-26T21:00:00Z

Location: ~/wt-usage-tests/2026-02-26T21-00-00/
Tests performed:
- `wt stash drop` abort on N (VISION §5.2.1): created stash for feature/alpha via eviction; ran `wt stash drop feature/alpha` and sent "N" — printed "Drop stash for 'feature/alpha'? This cannot be undone. [y/N] Aborted." with exit 0; subsequent `wt stash list` confirmed stash entry still present — abort preserves stash, clean exit
- `wt checkout -b <branch>` with no start point (VISION §3.3): ran `wt checkout -b from-head-no-start` with no start point argument — branch created from `origin/main` (the remote default branch) with message "wt: Created branch from-head-no-start from origin/main"; correct per VISION §3.3 "If <start-point> is omitted, the new branch is created from origin/<default-branch>"
- Stash archival gate: remote branch still exists (VISION §5.3): faked `last_used_at` to 8 days ago for feature/alpha stash; ran `wt fetch` while remote branch `feature/alpha` still existed — stash NOT archived (correct: both conditions required — old last_used_at AND remote branch deleted); then deleted remote branch and ran `wt fetch` again — stash correctly archived ("Archived 1 stash(es): feature/alpha", warning about missing zstd); archival two-condition gate confirmed
- `wt pin`/`wt unpin` error cases (VISION §11): `wt pin nonexistent-slot-xyz` → "wt: Slot 'nonexistent-slot-xyz' not found." (exit 1); `wt unpin nonexistent-slot-xyz` → same (exit 1); `wt pin raw-fern-dim` then `wt pin raw-fern-dim` again → "Slot 'raw-fern-dim' is already pinned." (exit 0, idempotent); `wt unpin bench-algae-mole` (not pinned) → "Slot 'bench-algae-mole' is not pinned." (exit 0, idempotent); all four error cases handled cleanly
- `wt stash apply <branch>` from a different slot (VISION §5.2.1): feature/alpha checked out in mist-forest-thorn with an active stash; from within raw-fern-dim (trigger-evict slot), ran `wt stash apply feature/alpha` — stash applied correctly to mist-forest-thorn (the slot where feature/alpha was checked out), not to raw-fern-dim; feature/alpha slot became dirty; stash list empty after apply; cross-slot stash apply works as specified
Result: PASS

## 2026-02-26T22:00:00Z

Location: ~/wt-usage-tests/2026-02-26T22-00-00/
Tests performed:
- Rebase-after-eviction stash restore (VISION §5.2): created dirty state (staged + untracked) on feature/rebase-test, evicted to create stash (base commit f334032); then force-pushed rebased feature/rebase-test to remote (new tip 2dbad06 with additional commit modifying same file); fetched; re-checkout of feature/rebase-test evicted another slot and applied stash — git stash apply succeeded without conflicts (exit 0), stash consumed, untracked file (untracked-dirty.txt) restored; note: the rebased line ("remote line added after rebase") was overwritten by the stash patch since git applied the diff against the old base — standard git stash behavior, not a wt bug
- Stash operations on branch with multiple `/` in name (VISION §5): checked out `feature/stash/encoded`, created dirty state (staged README.md + untracked), evicted to create stash; verified stash metadata file named `feature--stash--encoded.toml` (correct double-dash encoding); `wt stash list` displays `feature/stash/encoded` correctly; `wt stash show feature/stash/encoded` displays full diff including staged and untracked files; `wt stash drop feature/stash/encoded` with `y` deletes the encoded file and clears the list — all stash operations work end-to-end with encoded branch names containing multiple slashes
- `wt fetch` on no-remote repo (VISION §12): initialized wt from a local-only repo (no remote); ran `wt fetch` — git fetch exits 0 with no output when no remote is configured; wt prints "Fetched latest from remote." and sets last_fetch_at; slightly misleading message but correct per vision principle "git errors pass through verbatim" (git reports success, wt reports success); no crash, exit 0
- `wt sync` with missing template source (VISION §7): configured `[[templates]]` with `source = "nonexistent-template.txt"` that does not exist in `.wt/`; ran `wt sync` — printed "wt: template source not found: <full-path>" once per slot (5 messages total for 5 slots), exit 0; message is clear and actionable; exit 0 allows other sync operations to proceed; 5 redundant messages (one per slot for same missing source) are verbose but acceptable since VISION.md specifies no behavior for this case
Result: PASS

## 2026-02-26T23:00:00Z

Location: ~/wt-usage-tests/2026-02-26T23-00-00/
Tests performed:
- `wt stash apply` to a slot with existing dirty state (VISION §5.2): checked out `feature/dirty-stash` with `--no-restore` (stash retained); created new dirty state in that slot (modified `stash-target.txt` + new `new-untracked.txt`); attempted `wt stash apply feature/dirty-stash` — git returned "Your local changes would be overwritten by merge: stash-target.txt. Aborting"; wt treated this as a conflict (exit 1 from git stash apply), emitted "wt: Stash for feature/dirty-stash produced conflicts. Resolve manually." and retained the stash ref; stash confirmed still present in `wt stash list`; working tree unchanged (stash not applied to tracked file); untracked file from stash (`untracked.txt`) was partially applied by git before aborting — standard git stash apply behavior; exit 0; stash safely preserved for user to resolve
- `wt init` from empty non-git directory, no URL (VISION §2.1): ran `wt init` (no URL) from a newly-created empty directory with no `.git/`; received clear error "wt: Not at the root of a git repository. Run 'wt init' from the repository root (where .git/ lives), or use 'wt init <url>' to clone a new one." with exit 1; no partial state created — correct per VISION §2.1 (init without URL requires an existing git repo)
- New slot creation propagates symlinks and templates (VISION §6, §7): configured `directories = ["configs"]` and `[[templates]]` in config, ran `wt sync` — all 5 slots got `configs/app.env` symlink and `info.txt` template; then increased `slot_count` from 5 to 7; ran `wt list` — 2 new vacant slots (`worn-aloe-velvet`, `gleam-wane-rush`) created; verified all 7 slots have `configs/app.env` symlink and `info.txt` template; new vacant slots get `BRANCH=` (empty string) — slot count increase correctly propagates symlinks and templates to newly-created slots
- `wt checkout --no-restore` when branch has no stash (VISION §5.2): ran `wt checkout --no-restore feature/br-a` when `feature/br-a` had no stash in `.wt/stashes/`; checkout succeeded cleanly — navigated to existing slot (`bold-bland-inert`), no error about missing stash, exit 0; `--no-restore` is a no-op when no stash exists — correct per spec (restore is skipped only when a stash exists, non-existence is not an error)
- `wt -` from within a vacant slot (VISION Phase 1 §1.9): entered vacant slot `gleam-wane-rush` (no branch assigned); ran `wt -` from within it — correctly navigated to MRU non-vacant slot (`feature/br-a` in `bold-bland-inert`, last used "just now"); vacant slot not mistakenly treated as MRU; exit 0 — resume command correctly ignores vacant slots when determining MRU
Result: PASS

## 2026-02-27T00:00:00Z

Location: ~/wt-usage-tests/2026-02-27T00-00-00/
Tests performed:
- Empty `state.toml` graceful recovery (VISION §3.3): wrote empty (zero-byte) `.wt/state.toml` (valid but empty TOML); ran `wt list` — silently regenerated state from git worktree state with epoch timestamps, showed all 5 slots correctly, exit 0; no crash, no spurious warning (empty TOML is valid, not corrupt — contrasts with corrupt TOML which emits a warning); state.toml rewritten with correct schema after the command
- Pinned occupied slots with vacant slots still available (VISION §11): pinned `glow-quill-solemn` (only occupied slot); ran `wt checkout feature/alpha` — correctly selected vacant slot `free-free-pore`, printed "Checked out feature/alpha in free-free-pore"; the pinned `glow-quill-solemn` was not evicted; pin is irrelevant when vacant slots exist, per VISION §11
- `wt stash apply` on archived stash (VISION §5.3, §5.2.1): created active stash for `feature/stash-archive-test`, aged metadata to 56 days, deleted remote branch, ran `wt fetch` to archive; stash archived to `.wt/stashes/archive/feature--stash-archive-test.patch`; ran `wt stash apply feature/stash-archive-test` — returned "wt: Stash for 'feature/stash-archive-test' is archived and cannot be restored. View diff with 'wt stash show feature/stash-archive-test'." with exit 1; clear actionable error, no crash; archived stash is read-only (view only)
- `slot_count` decrease when vacant slots exist (VISION §10.1): fresh container with 1 occupied (sol-deer-fresh/main) and 4 vacant slots; decreased slot_count from 5 to 3; ran `wt list` — 2 vacant slots removed (acorn-weasel-well, onyx-poplar-stout), occupied sol-deer-fresh/main preserved; result: 3 slots (1 occupied + 2 vacant); vacant slots evicted first before occupied slots, correct per VISION §10.1 LRU semantics (vacant slots have epoch timestamps = LRU)
- Multiple `[[templates]]` entries simultaneously (VISION §7.1): configured 2 `[[templates]]` blocks (`env.template → .env.local`, `docker.template → docker-compose.override.yml`); ran `wt sync` — both templates generated in all 3 slots; active slot (sol-deer-fresh/main) got `BRANCH=main` in both files; 2 vacant slots got `BRANCH=` (empty) and correct `SLOT=<name>` in both files; multiple templates coexist and generate correctly in one sync pass
Result: PASS
## 2026-02-27T01:00:00Z

Location: ~/wt-usage-tests/2026-02-27T01-00-00/
Tests performed:
- TUI launch from inside container (VISION §8): ran `node /workspace/bin/wt.mjs` with no args from inside a fresh container via pseudo-TTY (`script -q -c`); TUI launched and rendered the main menu with all 5 options: "Manage Worktrees" (selected), "Manage Stashes", "Edit Configuration", "Edit Templates", "Edit Hooks"; navigation hint shown (↑/↓ navigate, Enter select, q quit); TUI correctly appears instead of CLI help when inside a managed container — correct per VISION §8
- `wt hooks show claude-code` (VISION §16.2): ran from inside container, output valid JSON with PreToolUse and PostToolUse hooks as specified in VISION §16.2; `wt pin 2>/dev/null || true` and `wt unpin 2>/dev/null || true` commands included; exit 0; output matches VISION §16.2 exactly
- Post-checkout hook exit code not propagated (VISION §4.3): shell function runs the hook after cd but does NOT capture or propagate the hook exit code; the function returns the binary's exit code (`$exit_code`), not the hook's exit code; a hook that exits 1 is silently ignored by the shell function; VISION §4.3 does not specify behavior when hook fails, so this is an undocumented gap — hook failures are silent
- `wt init <bad-url>` partial state leak (VISION §2.2): ran `wt init http://not-a-real-git-repo-xyz.invalid/nonexistent.git` in an empty dir; git clone failed with "fatal: unable to access...: Could not resolve host" (exit 128) and printed verbatim (correct per VISION §15.3); but the `.wt/` directory structure was already created by `createContainerStructure()` before the clone failed, leaving a partial `.wt/{repo,hooks,shared,stashes,templates}/` tree behind; a retry `wt init <any-url>` immediately fails with "Directory is not empty" because the partial `.wt/` makes the dir non-empty; user is stuck and must manually `rm -rf .wt` to recover — BUG-031
Result: BUG FOUND
Bug: BUG-031 — `wt init <url>` leaves partial `.wt/` directory on clone failure, blocking retry

## 2026-02-27T02:00:00Z

Location: ~/wt-usage-tests/2026-02-27T02-00-00/
Tests performed:
- Missing `.wt/config.toml` (VISION §15.1): deleted config.toml, ran `wt list` and `wt checkout local-base` — both succeeded with default values applied (slot_count=5, archive_after_days=7, fetch_cooldown_minutes=10); config file is NOT auto-recreated (remains absent); graceful fallback to defaults with no warning or error, exit 0 — missing config is handled identically to a config with all defaults
- Corrupt `.wt/config.toml` (VISION §15.1): wrote invalid TOML to config.toml; ran `wt list` — hard failure with "wt: Invalid TOML document: only letter, numbers, dashes and underscores are allowed in keys" (exit 1); error message shows the bad line content but does not explicitly say "config.toml is corrupted" (unlike state.toml which says "Warning: .wt/state.toml is corrupted. Regenerating from git state."); inconsistency is acceptable since config has no automatic regeneration path (user config cannot be inferred from git state); VISION §15.1 "clear error message and exit with code 1" is satisfied
- `wt sync` idempotency (VISION §6, §7): configured shared `directories = ["configs"]` and one `[[templates]]` entry; ran `wt sync` — first run created symlinks and template files in all 5 slots; ran `wt sync` again (second time) — clean exit 0, no duplicate symlinks, no error, no extraneous output; slot directories unchanged; second sync is a clean no-op — idempotency confirmed
- `wt checkout -b <new-branch> <local-branch>` as start point (VISION §3.0): ran `wt checkout -b feature/from-local-base local-base` where `local-base` is an existing local branch (not a remote ref, not a SHA); checkout succeeded in vacant slot `true-bold-pipit`, printed "wt: Created branch feature/from-local-base from local-base"; new branch content confirmed (includes commits from local-base); pre-validation passes (branch does not exist), start point resolves — using a local branch name as `-b` start point works correctly
- Binary without `WT_SHELL_INTEGRATION` (VISION §4.2): ran `node /workspace/bin/wt.mjs checkout main` with `WT_SHELL_INTEGRATION` unset; checkout succeeded with "wt: Checked out main in swan-spur-long" (no "Navigating to" line) — correct; nav file WAS written to `/tmp/wt-nav-<ppid>` pointing to correct slot path — this is correct per VISION §4.2: the binary always writes the nav file, and the shell wrapper is responsible for reading and deleting it; without the shell wrapper, nav files accumulate in /tmp until cleaned by the OS; this is by-design behavior
Result: PASS

## 2026-02-27T03:00:00Z

Location: ~/wt-usage-tests/2026-02-27T03-00-00/
Tests performed:
- BUG-031 fix verification (`wt init <bad-url>` cleanup): ran `wt init http://not-a-real-git-repo-xyz.invalid/nonexistent.git` in an empty directory — git clone failed verbatim ("fatal: unable to access..."), `.wt/` directory was NOT left behind (directory is clean for retry); immediately retried with a real local bare repo — `wt init` succeeded, 5 slots created (1 active on main, 4 vacant), slot summary printed correctly; BUG-031 fix confirmed working
- `wt -` when all slots are vacant (VISION Phase 1 §1.9): detached HEAD in the only active slot (terra-slope-ruff/main) directly via `git checkout --detach`, making all 5 slots vacant; ran `wt -` — returned "wt: No worktree slots are currently in use." with exit 1; correct per spec ("If all slots are vacant, print an error")
- Shell function exit code propagation (VISION §4.1): defined shell wrapper calling `node /workspace/bin/wt.mjs` with nav file logic; ran `wt checkout totally-nonexistent-branch-for-test-xyz` via wrapper — binary printed "wt: Branch 'totally-nonexistent-branch-for-test-xyz' not found locally or on remote." (exit 1); shell function propagated exit code 1; cwd unchanged after failure — shell function correctly returns binary exit code
- `wt sync` with deeply nested shared directory structure (VISION §6): created `.wt/shared/shared-configs/` with files at 3 levels: `top.env`, `nested/nested.env`, `nested/deep/deep.env`; ran `wt sync` — created correct relative symlinks in all 5 slots at all depths: `../../.wt/shared/shared-configs/top.env`, `../../../.wt/shared/shared-configs/nested/nested.env`, `../../../../.wt/shared/shared-configs/nested/deep/deep.env`; all symlinks resolve and content is correct; note: writing `directories = ["shared-configs"]` at top-level TOML (instead of under `[shared]`) silently does nothing — no error, correct per parser semantics
- `wt checkout <branch>` when branch already in slot but slot has dirty state (VISION §3.1): modified README.md and added untracked file in main's slot (terra-slope-ruff); ran `wt checkout main` from container root — navigated directly ("wt: Checked out main in terra-slope-ruff", exit 0); dirty state (modified README.md + untracked file) was NOT stashed — preserved exactly as-is; stash list remains empty; correct per VISION §3.1 ("if branch already in a slot: navigate there directly, no stash")
Result: PASS
