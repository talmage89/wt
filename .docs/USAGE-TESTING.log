# Usage Testing Log

Previous test runs archived to `.docs/archive/USAGE-TESTING.log`.

## 2026-02-26T08:30:00Z

Location: ~/wt-usage-tests/2026-02-27T18-00-00Z/
Tests performed:
- `wt -` (resume) from container directory — correctly navigated to MRU slot (feature/dashboard in thrush-notch-swamp). ✓
- `wt -` from within MRU slot — correctly printed "Already in the most recently used worktree (feature/dashboard in thrush-notch-swamp)" and exited 0. ✓
- `wt -` from completely outside container (/tmp) — correctly printed "Not inside a wt-managed container." and exited 1. ✓
- `wt -` when all slots are vacant (detached all slots manually) — correctly printed "No worktree slots are currently in use." and exited 1. ✓
- `wt checkout -b main` (branch already exists) — pre-validation correctly rejected before eviction: "Branch 'main' already exists." exit 1. Slot state unchanged. ✓
- `wt checkout -b feature/auth` (branch already exists) — same pre-validation rejection. ✓
- `wt checkout -b new-feature bad-sha-that-doesnt-exist` — git error passed through verbatim: "fatal: Needed a single revision" exit 128. No eviction occurred. ✓
- `wt stash show feature/auth` when no stash exists — "No stash found for branch 'feature/auth'." exit 1. ✓
- `wt stash apply feature/auth` when branch not in any slot (but stash exists) — "Branch 'feature/auth' is not checked out in any slot. Run 'wt checkout feature/auth' first." exit 1. ✓
- Stash auto-restore on checkout: created dirty state in feature/auth (1 modified + 1 untracked file), evicted via LRU checkout, stash created. Checked out feature/auth: evicted main, restored stash ("Restored stash from 1 minute ago"), verified both files present, stash list now empty. ✓
- Fetch cooldown: cooldown=10min; second checkout within seconds correctly skipped fetch (timestamp unchanged). Setting `fetch_cooldown_minutes=0` caused immediate re-fetch on next checkout (timestamp updated). ✓
Result: PASS

## 2026-02-27T05:30:00Z

Location: ~/wt-usage-tests/2026-02-27T05-30-00Z/
Tests performed:
- Config value validation — negative slot_count: `slot_count = -1` and `slot_count = 0` correctly fail with "wt: slot_count must be at least 1." (exit code 1). Validation is in `slots.ts` `adjustSlotCount()`. ✓
- Config value validation — string slot_count: `slot_count = "abc"` (valid TOML string type) silently falls back to default (5). No error or crash. By design: config parser uses `typeof parsed["slot_count"] === "number"` guard, so non-numeric types fall back to defaults for forward-compatibility. Consistent with unknown-key behavior.
- Config value validation — negative fetch_cooldown_minutes: `fetch_cooldown_minutes = -5` silently accepted; no error. Negative cooldown means elapsed time is always >= threshold, so every command would fetch. Not ideal UX but not a crash.
- Stale nav file from crashed session: manually wrote `/some/old/path` to `/tmp/wt-nav-99999`. Running `wt checkout` in a different session (different PID) ignored the stale file — each session uses its own `$$` PID for the nav file, so stale files from other PIDs are harmless. Stale files accumulate in /tmp/ but cause no functional issues. ✓
- Hook stdout/stderr output during checkout: created `.wt/hooks/post-checkout` that writes to both stdout and stderr. Via shell function, both outputs were correctly visible to the user after `wt` messages. Hook ran with correct args ($1 = worktree path, $2 = branch name). ✓
- Hook non-zero exit code: hook that exits 1 — error message visible (stderr shown), but shell function returns wt binary's exit code (0), not hook's exit code (1). The shell function uses `return $exit_code` from the `command wt` call; hook exit code is not captured. CWD change still happens. Behavior is consistent (checkout succeeded; hook failure doesn't undo navigation). Not a bug per vision (no spec on hook exit propagation).
- `wt stash show` on archived stash: archived stash (stored as `.patch` file after zstd-less archival) correctly shown with full diff including untracked files. Output format slightly different (patch file uses `# --- untracked files ---` separator). ✓
- `wt clean` full lifecycle: one archived stash; tested all interactive paths: (a) select "all" → confirm "y" → deleted correctly; (b) select "1" (number) → confirm "n" → aborted (stash preserved); (c) select "none" → aborted immediately; (d) invalid input "y" → "No valid selection. Aborted." Selection format is comma-separated numbers, "all", or "none". All paths exit 0. ✓
- Stash archival lifecycle end-to-end: dirty eviction → active stash → manipulate metadata to old date + delete remote branch → `wt fetch` triggers archival (with "Archived 1 stash(es):" message and zstd-not-found warning) → stash shows as "archived" in list → `wt clean all` with "y" → patch file deleted from `.wt/stashes/archive/` and metadata removed. Full workflow verified. ✓
Result: PASS

## 2026-02-27T09:00:00Z

Location: ~/wt-usage-tests/2026-02-27T09-00-00Z/
Tests performed:
- `wt fetch` bypasses cooldown (Phase 1 §1.6): set `fetch_cooldown_minutes = 10`, ran `wt checkout` to set `last_fetch_at`, then immediately ran `wt fetch` — fetch ran successfully despite being within the 10-minute window, discovered newly-pushed branch-d, updated `last_fetch_at`; confirms explicit `wt fetch` always fetches regardless of cooldown
- `wt stash drop` for branch with no stash (VISION §5.2.1): tried `wt stash drop no-stash-branch` and `wt stash drop main` — both returned "wt: No stash found for branch 'X'" with exit code 1; clean error messages
- Symlink dynamically appears/disappears on checkout between branches (VISION §6.3): checked out branch-b (no tracked configs/app.env) into slot → symlink created at slot/configs/app.env pointing to .wt/shared; evicted that slot and checked out branch-d (tracks configs/app.env) → symlink was correctly replaced by git-tracked regular file, with "Skipping symlink: file is tracked by git" printed; observation: wt list shows slot as "dirty" when slot has only wt-managed untracked symlinks, but on eviction saveStash() removes managed symlinks before stashing so no stash is created (by design — symlinks are recreated on checkout); the dirty indicator is technically accurate (git status sees them) but no user state is lost
- `wt -` from inside MRU slot (Phase 1 §1.9): ran `wt -` from inside rind-willet-fern (the MRU slot, branch-d) — printed "wt: Already in the most recently used worktree (branch-d in rind-willet-fern)" with exit code 0, no navigation; correct no-op behavior
- `wt checkout` when remote is unreachable (VISION §15.3): changed remote URL to http://localhost:9999/nonexistent.git, reset fetch cooldown; ran `wt checkout branch-a` — git error printed verbatim ("fatal: unable to access…"), checkout of already-local branch-a succeeded (exit 0); ran `wt checkout totally-nonexistent-branch` — git fetch error printed verbatim, then "wt: Branch 'totally-nonexistent-branch' not found locally or on remote" (exit 1); fetch errors are non-fatal for local branches but correctly fail for nonexistent branches
Result: PASS

## 2026-02-27T07:00:00Z

Location: ~/wt-usage-tests/2026-02-27T07-00-00Z/
Tests performed:
- Checkout already-in-slot branch from different directory: `wt checkout feature/alpha` when feature/alpha is already in sheer-tern-pebble — navigates to existing slot without eviction or stash; prints "wt: Checked out feature/alpha in sheer-tern-pebble" only
- Checkout current branch from within its slot: `wt checkout main` from inside the main slot (bale-vista-bold) — no-op navigation, prints "wt: Checked out main in bale-vista-bold", no eviction
- `--no-restore` then manual `wt stash apply` flow: evicted feature/alpha with dirty state (creating stash), re-checked-out with `--no-restore` (stash preserved, working tree clean), then `wt stash apply feature/alpha` — stash applied, dirty state restored (alpha.txt modified + untracked.txt), stash cleaned up
- Multiple evictions of same branch (stash overwrite): evicted feature/alpha (stash #1 created), checked out with `--no-restore` (stash preserved), added new dirty state, evicted again — stash #1 silently overwritten by stash #2; restored stash contains latest dirty state only; old stash #1 data (original untracked.txt) is lost without warning — this is by design per current implementation
- `wt init <url>` into dotfile-only directory: directory with single `.gitkeep` file — correctly rejected with "Directory is not empty" error; directory remains clean with no partial `.wt/` created
Result: PASS

## 2026-02-26T04:20:00Z

Location: ~/wt-usage-tests/2026-02-26T04-20-00/
Tests performed:
- `wt init <remote-url>`: init from a local bare repo used as remote — verified slot summary (5 slots, one on main, four vacant) and shell integration hint printed correctly
- `wt list`: verified tabular output shows slot name, branch, status, pinned flag, and last-used timestamp
- `wt -` (resume command): checked out feature/login then feature/signup; ran `wt -` — correctly navigated to most-recently-used slot (onyx-algae-wood / feature/signup), nav file written to correct path
- Shell integration: `wt shell-init bash` outputs valid `wt()` function; nav file written by binary at `/tmp/wt-nav-<ppid>`; checkout prints "wt: Navigating to <dir>"
- Reconciliation: directly ran `git checkout -b local-only-branch` inside gravel-puffin-wynd slot (bypassing wt); subsequent `wt list` silently updated state to show local-only-branch — no errors, no warnings
Result: PASS

## 2026-02-26T05:30:00Z

Location: ~/wt-usage-tests/2026-02-26T05-30-00/
Tests performed:
- Checkout branch with `/` in name (`feature/auth/oauth`): correctly checked out into slot, branch name displayed accurately in `wt list`, slot directory populated correctly — encoding/decoding of `/` works
- Eviction with full dirty state (staged + unstaged + untracked): filled all 5 slots, created dirty state in main slot (MM README.md + ?? new-untracked.txt), triggered eviction by checking out new branch — eviction stashed dirty state, restore on re-checkout returned all changes including untracked file
- Pin all slots then checkout new branch: pinned all 5 slots, ran `wt checkout -b should-fail-all-pinned` — received clear error "All worktree slots are pinned. Unpin a worktree or increase the slot count to continue." with exit 1, no partial state left
- Slot count increase via config: edited `.wt/config.toml` directly (slot_count 5→7), ran `wt list` — two new vacant slots created immediately (tundra-loam-brisk, lupine-rustic-ruby) with `git worktree add` printed to terminal
- `wt checkout -b` pre-validation: tried `wt checkout -b main` (existing branch) → "wt: Branch 'main' already exists." with exit 1, no eviction; tried `wt checkout -b new-branch nonexistent-sha` → git fatal error with exit 128, no eviction
Result: PASS

## 2026-02-26T06:30:00Z

Location: ~/wt-usage-tests/2026-02-26T06-30-00/
Tests performed:
- Stash commands (list/show/drop + error cases): created dirty state (staged + untracked), triggered eviction, verified `wt stash list` shows entry; `wt stash show <branch>` displays full diff including untracked files; `wt stash show <branch-with-no-stash>` returns "No stash found" with exit 1; `wt stash apply <nonexistent-branch>` returns "No stash found" with exit 1; `wt stash drop <branch>` prompts for confirmation, drops stash on `y`; list shows empty after drop
- `wt checkout --no-restore` + manual apply: evicted branch with dirty state (staged README.md + untracked file), then checked it back out with `--no-restore` — dirty state was NOT restored (clean working tree), stash entry was preserved; `wt stash apply <branch>` then successfully restored all changes; note: staged change is restored as unstaged after apply (standard git behavior without --index, per spec)
- Slot count decrease via config (5→3): edited config directly, ran `wt list` — 2 LRU slots (puffin-hoar-silent/main, clam-spur-dune/br-a) were silently evicted, directories removed, 3 slots remain
- Slot count decrease below pinned count: pinned all 3 remaining slots, decreased slot_count to 2 → error "Cannot reduce slot count to 2: 3 worktrees are pinned. Unpin worktrees first or choose a higher count." with exit 1, no eviction
- Fetch cooldown: first checkout records `last_fetch_at` in state.toml; second checkout within 10 min does NOT update timestamp (fetch skipped); explicit `wt fetch` always runs and updates timestamp; setting `fetch_cooldown_minutes = 0` in config causes every checkout to fetch
Result: PASS

## 2026-02-26T07:30:00Z

Location: ~/wt-usage-tests/2026-02-26T07-30-00/
Tests performed:
- `wt init` twice: second `wt init` on already-initialized container returns "Directory is not empty" with exit 1 — clear error, no corruption
- `wt checkout main` when main already checked out: correctly navigates to existing slot (orbit-sharp-light), prints "Checked out main in orbit-sharp-light", nav file written with correct path — no spurious eviction
- `wt checkout remote-only-branch` (branch exists only on remote): checkout succeeded, git DWIM created local tracking branch — but "Created local branch remote-only-branch from origin/remote-only-branch" message was NOT printed (BUG-029)
Result: BUG FOUND
Bug: BUG-029 — "Created local branch" message missing when remote-only branch checkout succeeds via git DWIM

## 2026-02-26T09:00:00Z

Location: ~/wt-usage-tests/2026-02-26T09-00-00/
Tests performed:
- Symlink shared file creation: configured `directories = ["configs"]`, placed `.wt/shared/configs/app.env`, ran `wt sync` — symlinks created correctly in all 5 slots (`configs/app.env -> ../../.wt/shared/configs/app.env`)
- Git-tracked file takes precedence over symlink: created `feature/gamma` branch with `configs/app.env` as a git-tracked file; `wt checkout feature/gamma` removed the pre-existing symlink (via `removeSymlinks` step 9), git placed the tracked file, then `establishSymlinks` detected the file was tracked and skipped creating the symlink (printed "Skipping symlink for configs/app.env: file is tracked by git in branch feature/gamma.") — result: slot has the branch-specific tracked file, not the shared symlink
- Template expansion: configured `[[templates]]` with `source = "build.sh.template"`, `target = "build.sh"`, variables `{{BRANCH_NAME}}` and `{{WORKTREE_DIR}}`; `wt sync` generated `build.sh` correctly in all slots with branch-specific values; vacant slot gets empty `{{BRANCH_NAME}}`
- Reconciliation with deleted slot dir: manually `rm -rf bolt-mild-lucid`; ran `wt list` — reconcile detected missing slot, silently ran `git worktree add` to create a new slot (`newt-flume-larch`), maintaining the configured 5-slot count; no crash, clean output
- Broken symlink cleanup: deleted canonical `.wt/shared/configs/app.env` file; ran `wt sync` — all broken symlinks in all slots were removed correctly
Result: PASS

## 2026-02-26T10:00:00Z

Location: ~/wt-usage-tests/2026-02-26T10-00-00/
Tests performed:
- Stash archival lifecycle: created dirty state on `will-be-deleted`, evicted to create stash, faked `last_used_at` to 8 days ago in stash metadata, deleted remote branch from bare repo, ran `wt fetch` — stash archived correctly ("Archived 1 stash(es): will-be-deleted"), patch file written to `.wt/stashes/archive/will-be-deleted.patch` containing full diff including untracked files; note: zstd not available so patch stored uncompressed (expected "Warning: zstd not found. Archived stash stored uncompressed.")
- Drop archived stash: ran `wt stash list` — showed entry with status "archived"; `wt stash drop will-be-deleted` with confirmation → "Stash dropped for 'will-be-deleted'"; archive patch file deleted from disk; `wt stash list` showed "No saved stashes." — full archived stash lifecycle verified
- Corrupt state.toml: wrote invalid TOML (`%CORRUPTED TOML%\n[[[bad section\nkey =`) to `.wt/state.toml`; ran `wt list` — printed "Warning: .wt/state.toml is corrupted. Regenerating from git state." to stderr, then successfully regenerated all 5 slots from git worktree list with epoch timestamps (20510d ago), clean exit code 0 — graceful recovery confirmed
- Manual `git worktree add` in container: ran `git --git-dir=.wt/repo worktree add ./manual-worktree -b manual-branch` directly (bypassing wt); ran `wt list` — reconcile discovered `manual-worktree` as a new slot and added it to state; but because slot count in config is 5 and there were now 6 slots (5 original + manual), `adjustSlotCount` LRU-evicted one original slot (`arch-short-wynd`, branch-a) since all had epoch timestamps from the prior state corruption recovery; `manual-worktree` (manual-branch) appeared in the list as a managed slot — adoption of external worktrees works, slot count enforcement is immediate
Result: PASS

## 2026-02-26T11:00:00Z

Location: ~/wt-usage-tests/2026-02-26T11-00-00/
Tests performed:
- Post-checkout hook (VISION §4.3): created `.wt/hooks/post-checkout` (executable) that writes `HOOK_FIRED: path=<dir> branch=<branch>` to a log file; sourced shell integration, ran `wt checkout feature/hook-test2` via the shell function — hook fired correctly with `$1` = absolute worktree path and `$2` = branch name; shell cd'd to slot, then hook executed in correct order
- `wt clean` command (VISION §5.5): created stash, faked `created_at`/`last_used_at` to 8 days ago, deleted remote branch, ran `wt fetch` — stash archived; ran `wt clean` with no input → "Aborted." gracefully; with input "1" (select stash) → showed "Delete 1 stash? [y/N]" confirmation; with input "1\ny" → "Deleted 1 archived stash.", patch file removed, `wt stash list` shows "No saved stashes."
- Stash restore with conflicts (VISION §5.2, §15.2): created stash at commit e9de83f with `conflict-file.txt` modifications; then advanced local branch to a new commit (3d90e0a) where `conflict-file.txt` has conflicting content; re-checkout triggered stash apply failure — wt printed "wt: Stash for conflict-test produced conflicts. Resolve manually." and "wt: Run 'wt stash drop conflict-test' after resolution, or 'wt stash show conflict-test' to inspect."; checkout succeeded (exit 0), conflict markers visible in working tree, stash retained (not deleted) — correct per spec
- `wt init` from inside existing repo (VISION §2.1): created plain git repo with README.md and one commit; ran `wt init` (no URL) from inside — `.git/` moved to `.wt/repo/`, 5 worktree slots created, active slot (`wide-pearl-ridge`) has `main` checked out with README.md; container root has no `.git` and no working files (correct); shell integration hint printed
Result: PASS

## 2026-02-26T12:00:00Z

Location: ~/wt-usage-tests/2026-02-26T12-00-00/
Tests performed:
- `wt init <url>` into non-empty non-git directory (VISION §15.1): created dir with single dotfile `.envrc`, ran `wt init <url>` — correctly failed with "Directory is not empty. Use 'wt init' from inside an existing repository, or run from an empty directory." (exit 1), no partial state left
- Evict all slots in sequence — stash accumulation (VISION §5.1): checked out 5 branches filling all slots, dirtied each with staged + untracked files, then triggered 5 sequential evictions via new checkouts — all 5 stash metadata TOML files accumulated in `.wt/stashes/`; `wt stash list` showed all 5 entries; re-checkout of branch-1 correctly restored staged and untracked files (newly-staged files restore as staged, consistent with git stash apply behavior)
- `wt -` from container directory vs. outside container (VISION §9, Phase 1 §1.9): from container root (outside any slot), `wt -` navigated to MRU slot correctly; from unrelated directory (`/tmp`), `wt -` correctly failed with "Not inside a wt-managed container." (exit 1) — expected since no container to infer
- Modify template source + `wt sync` regenerates all slots (VISION §7.4): created `templates/app.env` with `{{BRANCH_NAME}}` and `{{WORKTREE_DIR}}` variables, configured in `.wt/config.toml`; `wt sync` generated `.env` in all 5 slots; modified template source (changed APP_ENV and added DB_HOST); second `wt sync` regenerated all 5 `.env` files with new content — all slots updated correctly
- Unpin and immediately evict (VISION §11): pinned MRU slot, dirtied it, then unpinned; subsequent checkouts drove LRU selection; when slot finally became LRU candidate it was evicted with "dirty state stashed" message; `wt stash list` confirmed stash entry created for the formerly-pinned branch — pin removal correctly restores LRU eligibility
Result: PASS

## 2026-02-26T13:00:00Z

Location: ~/wt-usage-tests/2026-02-26T13-00-00/
Tests performed:
- BUG-029 fix verification (`wt checkout remote-only-feature`): set up a bare remote with `remote-only-feature` pushed only to remote; ran `wt init <remote>` then `wt checkout remote-only-feature` — checkout succeeded and git DWIM created a local tracking branch ("Switched to branch 'remote-only-feature'"), but the "wt: Created local branch remote-only-feature from origin/remote-only-feature" message was STILL NOT PRINTED — BUG-029 fix is ineffective. Root cause: `git clone --bare` creates `refs/heads/*` for ALL remote branches, so `git.refExists(repoDir, 'refs/heads/remote-only-feature')` returns `true` even for "remote-only" branches, causing `localBranchExistedBefore = true` and suppressing the message. The fix must use `branch_history` instead of `refExists` to detect first-time checkout.
Result: BUG FOUND
Bug: BUG-029 (re-opened) — BUG-029 fix ineffective: bare clone creates refs/heads/* for all remote branches, making localBranchExistedBefore always true

## 2026-02-26T15:00:00Z

Location: ~/wt-usage-tests/2026-02-26T15-00-00/
Tests performed:
- BUG-029 fix verification (`branch_history` approach): set up bare remote with `main` and `remote-only-feature` pushed; ran `wt init <remote>` then `wt checkout remote-only-feature` — `remote-only-feature` was absent from `branch_history` so `localBranchExistedBefore = false`; checkout succeeded and printed "wt: Created local branch remote-only-feature from origin/remote-only-feature" correctly; re-checkout of the same branch did NOT print the message (branch already in `branch_history`) — BUG-029 fix confirmed working
- Archived stash auto-restore warning (VISION §5.2, §10): created branch with staged + untracked dirty state, evicted it to create stash, faked `last_used_at` to 8 days ago, ran `wt fetch` to archive stash; re-checkout of the branch printed "wt: Archived stash for stash-archive-test was not auto-restored. View with 'wt stash show stash-archive-test'." before the checkout feedback line — correct per spec; archived stash is not deleted on checkout
- `wt checkout -b <branch> <explicit-start-point>` (VISION §3.3): tested `wt checkout -b explicit-start-test <full-SHA>` → "wt: Created branch explicit-start-test from <sha>"; tested `wt checkout -b from-origin-main origin/main` → "wt: Created branch from-origin-main from origin/main" — both start-point forms work correctly; pre-validation rejects invalid refs before eviction
- Re-stash (second eviction of same branch, VISION §5.1): evicted branch creating stash A (ref 8aaf604); re-checked-out restoring stash A (stash consumed); created new dirty state (additional changes on top of restored state); evicted branch again creating stash B (ref 615416c, different from A); `wt stash show` confirmed stash B contains accumulated dirty state from both rounds (first + second changes + both untracked files) — second eviction correctly replaces the consumed stash ref with a fresh one; no stash loss since first stash was properly restored before second eviction
Result: PASS

## 2026-02-26T16:00:00Z

Location: ~/wt-usage-tests/2026-02-26T16-00-00/
Tests performed:
- `wt co` and `wt ls` aliases (VISION §9): ran `wt ls` from container root — correct tabular output with slot, branch, status, pinned, last-used columns; ran `wt co feature/foo` — correct checkout with "wt: Created local branch feature/foo from origin/feature/foo" (BUG-029 fix re-confirmed: feature/foo not in branch_history, so message appears); both aliases function identically to their full-name counterparts
- `wt pin <slot-name>` and `wt unpin <slot-name>` by explicit slot name from outside the worktree (VISION §11): pinned `stoat-sharp-meadow` from container root — "Pinned 'stoat-sharp-meadow' (branch: main). It will not be evicted."; `wt ls` showed `pinned` flag; unpinned — "Unpinned 'stoat-sharp-meadow' (branch: main). It can now be evicted via LRU."; pin flag cleared — both commands work by slot name from any directory within the container
- `wt stash apply` with no branch arg (VISION §5.2.1): created stash for `feature/foo` via eviction; re-checked it out with `--no-restore`; ran `wt stash apply` from within the slot with no argument — correctly defaulted to current branch `feature/foo`, applied stash ("Stash applied and cleaned up for 'feature/foo'."), restored modified `foo.txt` and untracked `untracked.txt`; staged change restored as unstaged (standard git behavior)
- `wt stash drop` with no branch arg (VISION §5.2.1): created stash for `br-c` via eviction; re-checked out `br-c` with `--no-restore`; ran `wt stash drop` from within the slot with no argument — correctly defaulted to current branch `br-c`, prompted "Drop stash for 'br-c'? This cannot be undone. [y/N]"; confirmed with `y` → "Stash dropped for 'br-c'."; `wt stash list` showed "No saved stashes." — no-arg form works correctly
- `wt` with no args outside managed container (VISION §8): ran from `/tmp` — printed full CLI help listing all commands with descriptions and aliases; exit code 0 — correct behavior per spec ("display help/usage" when not inside managed container)
- Container discovery from deeply nested subdirectory (VISION §1, implicit): created `stoat-sharp-meadow/src/components/ui/buttons/`; ran `wt ls`, `wt stash list`, and `wt checkout main` from within — all correctly found the container by walking up the directory tree; `wt checkout main` navigated to `peat-gull-vivid` (already had main) without eviction — container discovery via parent-walk works at arbitrary depth
Result: PASS

## 2026-02-26T17:00:00Z

Location: ~/wt-usage-tests/2026-02-26T17-00-00/
Tests performed:
- `wt pin` / `wt unpin` with no arg from within a worktree (VISION §11): from within `hart-ember-pitch` (branch: main), ran `wt pin` with no argument — correctly auto-detected current slot, printed "Pinned 'hart-ember-pitch' (branch: main). It will not be evicted.", pin flag visible in `wt list`; `wt unpin` (no arg) correctly cleared pin flag — both commands auto-detect slot from cwd when no argument given
- `wt stash show` with no arg (VISION §5.2.1): checked out `br-b` with `--no-restore` (stash retained); from within `br-b`'s slot ran `wt stash show` (no arg) — defaulted to current branch `br-b`, displayed full stash diff including staged file and untracked file, exit 0; also tested error case: from main's slot after stash auto-restored, `wt stash show` (no arg) returned "No stash found for branch 'main'" with exit 0 — both cases correct
- `wt shell-init zsh` (VISION §4.1): output is syntactically valid (bash -n check passes); exports `WT_SHELL_INTEGRATION=1`; defines `wt()` function; includes nav file mechanism (`/tmp/wt-nav-$$`) and post-checkout hook execution; output is identical to bash shell-init (POSIX-compatible, valid for zsh)
- Clean eviction — no dirty state → no stash created (VISION §5.1): evicted `br-d` (clean slot) by checking out `br-g`; eviction message "wt: Evicted br-d from brisk-pool-snipe" had NO "(dirty state stashed)" suffix; stash list unchanged (no new entry for br-d); VISION §5.1 requirement "If the worktree has no dirty state, no stash is created" confirmed
- `wt sync` with no shared dirs or templates configured (VISION §6.4): config has `directories = []` and no `[[templates]]` entries; ran `wt sync` — completed cleanly with no output, exit 0; no stray files created in `.wt/shared/` or `.wt/templates/` — graceful no-op confirmed
Result: PASS

## 2026-02-26T18:00:00Z

Location: ~/wt-usage-tests/2026-02-26T18-00-00/
Tests performed:
- `wt stash apply <branch>` where branch is not in any slot (PHASE-2 checklist): created stash for `feature/alpha` via eviction; then checked out 5 other branches so feature/alpha had no slot; ran `wt stash apply feature/alpha` from container root — "wt: Branch 'feature/alpha' is not checked out in any slot. Run 'wt checkout feature/alpha' first." (exit 1); same error from within a different slot — consistent error messaging, no crash
- Template `{{BRANCH_NAME}}` on vacant (detached) slot (PHASE-2 checklist): created template with `source = "templates/info.txt"`, `target = "info.txt"` containing `SLOT={{WORKTREE_DIR}}` and `BRANCH={{BRANCH_NAME}}`; fresh container with 1 active slot (main) and 4 vacant; ran `wt sync` — active slot got `BRANCH=main`, all 4 vacant slots got `BRANCH=` (empty string); `{{WORKTREE_DIR}}` correctly expanded to slot name in all cases — empty string for BRANCH_NAME on detached slots is correct per PLAN.md
- Nav file written and cleaned up by shell function (PHASE-2 checklist): defined `wt()` wrapper around `node /workspace/bin/wt.mjs` with nav file cleanup logic; ran `wt checkout feature/alpha` through the function — binary wrote `/tmp/wt-nav-<shell-PID>` containing the target slot path; function read it, deleted it, and cded to target; after function completed, `/tmp/wt-nav-$$` was absent (confirmed "PASS: Nav file written and cleaned up by shell function"); "wt: Navigating to /path/..." printed as expected when `WT_SHELL_INTEGRATION=1`
- `wt -` from fresh container (VISION Phase 1 §1.9): `wt init` followed by `wt -` (no prior checkout beyond init) — correctly navigated to the only active slot (main in late-great-inert), printed "wt: Resuming main in late-great-inert" with exit 0; `wt -` when already at MRU slot — printed "wt: Already in the most recently used worktree (feature/alpha in peak-bur-thin)" with exit 0, no nav file written — correct no-op behavior per spec
- `wt clean` with no archived stashes (VISION §5.5): container had one active stash (br-e, status=active); ran `wt clean` with no input — printed "No archived stashes to clean." with exit 0; the active stash was not touched; correct per spec ("Interactive prompt listing archived stashes" — nothing to list means clean exit)
Result: PASS

## 2026-02-26T19:00:00Z

Location: ~/wt-usage-tests/2026-02-26T19-00-00/
Tests performed:
- `wt checkout <nonexistent-branch>` (not local, not remote, VISION §15.3): attempted `wt checkout totally-nonexistent-branch-xyz` in a fresh container — printed "wt: Branch 'totally-nonexistent-branch-xyz' not found locally or on remote." (exit 1); no state mutation, all 5 slots unchanged; pre-validation fires before any eviction attempt — correct per BUG-028 fix / VISION §15.3
- `wt init` from a dirty repo with staged + untracked files (VISION §2.1): repo had staged `README.md` modification + untracked `untracked-file.txt`; `wt init` succeeded — `.git/` moved to `.wt/repo/`, 5 slots created, active slot (`luna-flock-spar`) showed dirty status in `wt list`; `git status` in slot confirmed untracked file preserved and modified content preserved; note: staged change becomes unstaged after init (standard git behavior when moving the .git dir and creating a worktree — the index transfers but worktree checkout is fresh); actual file content was not lost
- `wt stash list` / `wt stash show` / `wt stash apply` immediately after fresh init with zero stashes (VISION §5.2.1): no stash dir exists; `wt stash list` returned "No saved stashes." (exit 0); `wt stash show main` returned "wt: No stash found for branch 'main'." (exit 1); `wt stash apply main` returned "wt: No stash found for branch 'main'." (exit 1); no crash, graceful empty state handling
- `wt sync` real-file migration (VISION §6.4): configured `directories = ["configs"]`; created real (non-symlink, not git-tracked) files `app.env` and `extra.conf` in the active slot's `configs/` directory; ran `wt sync` — files migrated to `.wt/shared/configs/`; original files replaced with symlinks (`app.env -> ../../.wt/shared/configs/app.env`); content preserved correctly; vacant slot (`spur-steel-glen`) also got symlinks created — full migration + propagation confirmed
- `wt fetch` standalone command (VISION §12): first `wt fetch` when `last_fetch_at` not set — ran successfully, printed "Fetched latest from remote.", set `last_fetch_at` in state.toml; `wt checkout` within cooldown did not update timestamp (skipped fetch silently); second `wt fetch` always ran and updated timestamp (bypasses cooldown as expected); pushed new branch `test-fetch-branch` to remote, ran `wt fetch` — fetched new branch refs; subsequent `wt checkout test-fetch-branch` succeeded with "Created local branch test-fetch-branch from origin/test-fetch-branch" message — fetch-then-checkout roundtrip confirmed
Result: PASS

## 2026-02-26T20:00:00Z

Location: ~/wt-usage-tests/2026-02-26T20-00-00/
Tests performed:
- `wt shell-init fish` (VISION §4.1): output defines `function wt` with fish syntax; `set -gx WT_SHELL_INTEGRATION 1` exports the env var; nav file path uses `$fish_pid` (matches `process.ppid` in the binary when fish spawns the wt subprocess); includes nav file cleanup, `cd $target_dir`, post-checkout hook execution, and `return $exit_code` — all structural elements present and syntactically valid fish; parallel structure to bash/zsh versions confirmed
- `wt checkout` from within the LRU slot (evicting yourself, VISION §3.1): filled all 5 slots; from within `wombat-oriole-bent` (main, LRU, dirty state), ran `wt checkout feature/epsilon` — wt correctly identified and evicted `wombat-oriole-bent` as the LRU slot (printing "wt: Evicted main from wombat-oriole-bent (dirty state stashed)"), checked out `feature/epsilon` there, nav file written pointing back to the same directory; stash for `main` created and visible in `wt stash list`; no crash, correct behavior when the eviction target is your current working directory
- `wt stash show <branch>` on archived stash (VISION §5.2.1): created dirty state (staged + untracked), evicted to create stash, faked `last_used_at` to 8 days ago, deleted remote branch, ran `wt fetch` — stash archived to `feature--alpha.patch`; ran `wt stash show feature/alpha` on the archived stash — correctly read patch file and displayed full diff (staged change to alpha.txt + untracked file untracked-in-alpha.txt), exit 0; `wt stash show` on archived stash reads from the patch file correctly
- `wt init` from repo with no remote, then `wt checkout` of manually-created local branch (VISION §2.1, §3.2): initialized wt from a local-only git repo (no remote); init succeeded with 5 slots; then manually created a local branch via `git --git-dir=.wt/repo branch feature/local-only main`; ran `wt checkout feature/local-only` — checkout succeeded, but printed "wt: Created local branch feature/local-only from origin/feature/local-only" — INCORRECT: there is no remote and `origin/feature/local-only` does not exist; branch was a locally-created branch, not from a remote; the BUG-029 fix uses `branch_history` as proxy for "first time checkout = created from remote" which incorrectly fires for local-only branches (BUG-030)
Result: BUG FOUND
Bug: BUG-030 — "Created local branch from origin/X" message appears incorrectly for manually-created local branches and no-remote repos

## 2026-02-26T21:00:00Z

Location: ~/wt-usage-tests/2026-02-26T21-00-00/
Tests performed:
- `wt stash drop` abort on N (VISION §5.2.1): created stash for feature/alpha via eviction; ran `wt stash drop feature/alpha` and sent "N" — printed "Drop stash for 'feature/alpha'? This cannot be undone. [y/N] Aborted." with exit 0; subsequent `wt stash list` confirmed stash entry still present — abort preserves stash, clean exit
- `wt checkout -b <branch>` with no start point (VISION §3.3): ran `wt checkout -b from-head-no-start` with no start point argument — branch created from `origin/main` (the remote default branch) with message "wt: Created branch from-head-no-start from origin/main"; correct per VISION §3.3 "If <start-point> is omitted, the new branch is created from origin/<default-branch>"
- Stash archival gate: remote branch still exists (VISION §5.3): faked `last_used_at` to 8 days ago for feature/alpha stash; ran `wt fetch` while remote branch `feature/alpha` still existed — stash NOT archived (correct: both conditions required — old last_used_at AND remote branch deleted); then deleted remote branch and ran `wt fetch` again — stash correctly archived ("Archived 1 stash(es): feature/alpha", warning about missing zstd); archival two-condition gate confirmed
- `wt pin`/`wt unpin` error cases (VISION §11): `wt pin nonexistent-slot-xyz` → "wt: Slot 'nonexistent-slot-xyz' not found." (exit 1); `wt unpin nonexistent-slot-xyz` → same (exit 1); `wt pin raw-fern-dim` then `wt pin raw-fern-dim` again → "Slot 'raw-fern-dim' is already pinned." (exit 0, idempotent); `wt unpin bench-algae-mole` (not pinned) → "Slot 'bench-algae-mole' is not pinned." (exit 0, idempotent); all four error cases handled cleanly
- `wt stash apply <branch>` from a different slot (VISION §5.2.1): feature/alpha checked out in mist-forest-thorn with an active stash; from within raw-fern-dim (trigger-evict slot), ran `wt stash apply feature/alpha` — stash applied correctly to mist-forest-thorn (the slot where feature/alpha was checked out), not to raw-fern-dim; feature/alpha slot became dirty; stash list empty after apply; cross-slot stash apply works as specified
Result: PASS

## 2026-02-26T22:00:00Z

Location: ~/wt-usage-tests/2026-02-26T22-00-00/
Tests performed:
- Rebase-after-eviction stash restore (VISION §5.2): created dirty state (staged + untracked) on feature/rebase-test, evicted to create stash (base commit f334032); then force-pushed rebased feature/rebase-test to remote (new tip 2dbad06 with additional commit modifying same file); fetched; re-checkout of feature/rebase-test evicted another slot and applied stash — git stash apply succeeded without conflicts (exit 0), stash consumed, untracked file (untracked-dirty.txt) restored; note: the rebased line ("remote line added after rebase") was overwritten by the stash patch since git applied the diff against the old base — standard git stash behavior, not a wt bug
- Stash operations on branch with multiple `/` in name (VISION §5): checked out `feature/stash/encoded`, created dirty state (staged README.md + untracked), evicted to create stash; verified stash metadata file named `feature--stash--encoded.toml` (correct double-dash encoding); `wt stash list` displays `feature/stash/encoded` correctly; `wt stash show feature/stash/encoded` displays full diff including staged and untracked files; `wt stash drop feature/stash/encoded` with `y` deletes the encoded file and clears the list — all stash operations work end-to-end with encoded branch names containing multiple slashes
- `wt fetch` on no-remote repo (VISION §12): initialized wt from a local-only repo (no remote); ran `wt fetch` — git fetch exits 0 with no output when no remote is configured; wt prints "Fetched latest from remote." and sets last_fetch_at; slightly misleading message but correct per vision principle "git errors pass through verbatim" (git reports success, wt reports success); no crash, exit 0
- `wt sync` with missing template source (VISION §7): configured `[[templates]]` with `source = "nonexistent-template.txt"` that does not exist in `.wt/`; ran `wt sync` — printed "wt: template source not found: <full-path>" once per slot (5 messages total for 5 slots), exit 0; message is clear and actionable; exit 0 allows other sync operations to proceed; 5 redundant messages (one per slot for same missing source) are verbose but acceptable since VISION.md specifies no behavior for this case
Result: PASS

## 2026-02-26T23:00:00Z

Location: ~/wt-usage-tests/2026-02-26T23-00-00/
Tests performed:
- `wt stash apply` to a slot with existing dirty state (VISION §5.2): checked out `feature/dirty-stash` with `--no-restore` (stash retained); created new dirty state in that slot (modified `stash-target.txt` + new `new-untracked.txt`); attempted `wt stash apply feature/dirty-stash` — git returned "Your local changes would be overwritten by merge: stash-target.txt. Aborting"; wt treated this as a conflict (exit 1 from git stash apply), emitted "wt: Stash for feature/dirty-stash produced conflicts. Resolve manually." and retained the stash ref; stash confirmed still present in `wt stash list`; working tree unchanged (stash not applied to tracked file); untracked file from stash (`untracked.txt`) was partially applied by git before aborting — standard git stash apply behavior; exit 0; stash safely preserved for user to resolve
- `wt init` from empty non-git directory, no URL (VISION §2.1): ran `wt init` (no URL) from a newly-created empty directory with no `.git/`; received clear error "wt: Not at the root of a git repository. Run 'wt init' from the repository root (where .git/ lives), or use 'wt init <url>' to clone a new one." with exit 1; no partial state created — correct per VISION §2.1 (init without URL requires an existing git repo)
- New slot creation propagates symlinks and templates (VISION §6, §7): configured `directories = ["configs"]` and `[[templates]]` in config, ran `wt sync` — all 5 slots got `configs/app.env` symlink and `info.txt` template; then increased `slot_count` from 5 to 7; ran `wt list` — 2 new vacant slots (`worn-aloe-velvet`, `gleam-wane-rush`) created; verified all 7 slots have `configs/app.env` symlink and `info.txt` template; new vacant slots get `BRANCH=` (empty string) — slot count increase correctly propagates symlinks and templates to newly-created slots
- `wt checkout --no-restore` when branch has no stash (VISION §5.2): ran `wt checkout --no-restore feature/br-a` when `feature/br-a` had no stash in `.wt/stashes/`; checkout succeeded cleanly — navigated to existing slot (`bold-bland-inert`), no error about missing stash, exit 0; `--no-restore` is a no-op when no stash exists — correct per spec (restore is skipped only when a stash exists, non-existence is not an error)
- `wt -` from within a vacant slot (VISION Phase 1 §1.9): entered vacant slot `gleam-wane-rush` (no branch assigned); ran `wt -` from within it — correctly navigated to MRU non-vacant slot (`feature/br-a` in `bold-bland-inert`, last used "just now"); vacant slot not mistakenly treated as MRU; exit 0 — resume command correctly ignores vacant slots when determining MRU
Result: PASS

## 2026-02-27T00:00:00Z

Location: ~/wt-usage-tests/2026-02-27T00-00-00/
Tests performed:
- Empty `state.toml` graceful recovery (VISION §3.3): wrote empty (zero-byte) `.wt/state.toml` (valid but empty TOML); ran `wt list` — silently regenerated state from git worktree state with epoch timestamps, showed all 5 slots correctly, exit 0; no crash, no spurious warning (empty TOML is valid, not corrupt — contrasts with corrupt TOML which emits a warning); state.toml rewritten with correct schema after the command
- Pinned occupied slots with vacant slots still available (VISION §11): pinned `glow-quill-solemn` (only occupied slot); ran `wt checkout feature/alpha` — correctly selected vacant slot `free-free-pore`, printed "Checked out feature/alpha in free-free-pore"; the pinned `glow-quill-solemn` was not evicted; pin is irrelevant when vacant slots exist, per VISION §11
- `wt stash apply` on archived stash (VISION §5.3, §5.2.1): created active stash for `feature/stash-archive-test`, aged metadata to 56 days, deleted remote branch, ran `wt fetch` to archive; stash archived to `.wt/stashes/archive/feature--stash-archive-test.patch`; ran `wt stash apply feature/stash-archive-test` — returned "wt: Stash for 'feature/stash-archive-test' is archived and cannot be restored. View diff with 'wt stash show feature/stash-archive-test'." with exit 1; clear actionable error, no crash; archived stash is read-only (view only)
- `slot_count` decrease when vacant slots exist (VISION §10.1): fresh container with 1 occupied (sol-deer-fresh/main) and 4 vacant slots; decreased slot_count from 5 to 3; ran `wt list` — 2 vacant slots removed (acorn-weasel-well, onyx-poplar-stout), occupied sol-deer-fresh/main preserved; result: 3 slots (1 occupied + 2 vacant); vacant slots evicted first before occupied slots, correct per VISION §10.1 LRU semantics (vacant slots have epoch timestamps = LRU)
- Multiple `[[templates]]` entries simultaneously (VISION §7.1): configured 2 `[[templates]]` blocks (`env.template → .env.local`, `docker.template → docker-compose.override.yml`); ran `wt sync` — both templates generated in all 3 slots; active slot (sol-deer-fresh/main) got `BRANCH=main` in both files; 2 vacant slots got `BRANCH=` (empty) and correct `SLOT=<name>` in both files; multiple templates coexist and generate correctly in one sync pass
Result: PASS
## 2026-02-27T01:00:00Z

Location: ~/wt-usage-tests/2026-02-27T01-00-00/
Tests performed:
- TUI launch from inside container (VISION §8): ran `node /workspace/bin/wt.mjs` with no args from inside a fresh container via pseudo-TTY (`script -q -c`); TUI launched and rendered the main menu with all 5 options: "Manage Worktrees" (selected), "Manage Stashes", "Edit Configuration", "Edit Templates", "Edit Hooks"; navigation hint shown (↑/↓ navigate, Enter select, q quit); TUI correctly appears instead of CLI help when inside a managed container — correct per VISION §8
- `wt hooks show claude-code` (VISION §16.2): ran from inside container, output valid JSON with PreToolUse and PostToolUse hooks as specified in VISION §16.2; `wt pin 2>/dev/null || true` and `wt unpin 2>/dev/null || true` commands included; exit 0; output matches VISION §16.2 exactly
- Post-checkout hook exit code not propagated (VISION §4.3): shell function runs the hook after cd but does NOT capture or propagate the hook exit code; the function returns the binary's exit code (`$exit_code`), not the hook's exit code; a hook that exits 1 is silently ignored by the shell function; VISION §4.3 does not specify behavior when hook fails, so this is an undocumented gap — hook failures are silent
- `wt init <bad-url>` partial state leak (VISION §2.2): ran `wt init http://not-a-real-git-repo-xyz.invalid/nonexistent.git` in an empty dir; git clone failed with "fatal: unable to access...: Could not resolve host" (exit 128) and printed verbatim (correct per VISION §15.3); but the `.wt/` directory structure was already created by `createContainerStructure()` before the clone failed, leaving a partial `.wt/{repo,hooks,shared,stashes,templates}/` tree behind; a retry `wt init <any-url>` immediately fails with "Directory is not empty" because the partial `.wt/` makes the dir non-empty; user is stuck and must manually `rm -rf .wt` to recover — BUG-031
Result: BUG FOUND
Bug: BUG-031 — `wt init <url>` leaves partial `.wt/` directory on clone failure, blocking retry

## 2026-02-27T02:00:00Z

Location: ~/wt-usage-tests/2026-02-27T02-00-00/
Tests performed:
- Missing `.wt/config.toml` (VISION §15.1): deleted config.toml, ran `wt list` and `wt checkout local-base` — both succeeded with default values applied (slot_count=5, archive_after_days=7, fetch_cooldown_minutes=10); config file is NOT auto-recreated (remains absent); graceful fallback to defaults with no warning or error, exit 0 — missing config is handled identically to a config with all defaults
- Corrupt `.wt/config.toml` (VISION §15.1): wrote invalid TOML to config.toml; ran `wt list` — hard failure with "wt: Invalid TOML document: only letter, numbers, dashes and underscores are allowed in keys" (exit 1); error message shows the bad line content but does not explicitly say "config.toml is corrupted" (unlike state.toml which says "Warning: .wt/state.toml is corrupted. Regenerating from git state."); inconsistency is acceptable since config has no automatic regeneration path (user config cannot be inferred from git state); VISION §15.1 "clear error message and exit with code 1" is satisfied
- `wt sync` idempotency (VISION §6, §7): configured shared `directories = ["configs"]` and one `[[templates]]` entry; ran `wt sync` — first run created symlinks and template files in all 5 slots; ran `wt sync` again (second time) — clean exit 0, no duplicate symlinks, no error, no extraneous output; slot directories unchanged; second sync is a clean no-op — idempotency confirmed
- `wt checkout -b <new-branch> <local-branch>` as start point (VISION §3.0): ran `wt checkout -b feature/from-local-base local-base` where `local-base` is an existing local branch (not a remote ref, not a SHA); checkout succeeded in vacant slot `true-bold-pipit`, printed "wt: Created branch feature/from-local-base from local-base"; new branch content confirmed (includes commits from local-base); pre-validation passes (branch does not exist), start point resolves — using a local branch name as `-b` start point works correctly
- Binary without `WT_SHELL_INTEGRATION` (VISION §4.2): ran `node /workspace/bin/wt.mjs checkout main` with `WT_SHELL_INTEGRATION` unset; checkout succeeded with "wt: Checked out main in swan-spur-long" (no "Navigating to" line) — correct; nav file WAS written to `/tmp/wt-nav-<ppid>` pointing to correct slot path — this is correct per VISION §4.2: the binary always writes the nav file, and the shell wrapper is responsible for reading and deleting it; without the shell wrapper, nav files accumulate in /tmp until cleaned by the OS; this is by-design behavior
Result: PASS

## 2026-02-27T03:00:00Z

Location: ~/wt-usage-tests/2026-02-27T03-00-00/
Tests performed:
- BUG-031 fix verification (`wt init <bad-url>` cleanup): ran `wt init http://not-a-real-git-repo-xyz.invalid/nonexistent.git` in an empty directory — git clone failed verbatim ("fatal: unable to access..."), `.wt/` directory was NOT left behind (directory is clean for retry); immediately retried with a real local bare repo — `wt init` succeeded, 5 slots created (1 active on main, 4 vacant), slot summary printed correctly; BUG-031 fix confirmed working
- `wt -` when all slots are vacant (VISION Phase 1 §1.9): detached HEAD in the only active slot (terra-slope-ruff/main) directly via `git checkout --detach`, making all 5 slots vacant; ran `wt -` — returned "wt: No worktree slots are currently in use." with exit 1; correct per spec ("If all slots are vacant, print an error")
- Shell function exit code propagation (VISION §4.1): defined shell wrapper calling `node /workspace/bin/wt.mjs` with nav file logic; ran `wt checkout totally-nonexistent-branch-for-test-xyz` via wrapper — binary printed "wt: Branch 'totally-nonexistent-branch-for-test-xyz' not found locally or on remote." (exit 1); shell function propagated exit code 1; cwd unchanged after failure — shell function correctly returns binary exit code
- `wt sync` with deeply nested shared directory structure (VISION §6): created `.wt/shared/shared-configs/` with files at 3 levels: `top.env`, `nested/nested.env`, `nested/deep/deep.env`; ran `wt sync` — created correct relative symlinks in all 5 slots at all depths: `../../.wt/shared/shared-configs/top.env`, `../../../.wt/shared/shared-configs/nested/nested.env`, `../../../../.wt/shared/shared-configs/nested/deep/deep.env`; all symlinks resolve and content is correct; note: writing `directories = ["shared-configs"]` at top-level TOML (instead of under `[shared]`) silently does nothing — no error, correct per parser semantics
- `wt checkout <branch>` when branch already in slot but slot has dirty state (VISION §3.1): modified README.md and added untracked file in main's slot (terra-slope-ruff); ran `wt checkout main` from container root — navigated directly ("wt: Checked out main in terra-slope-ruff", exit 0); dirty state (modified README.md + untracked file) was NOT stashed — preserved exactly as-is; stash list remains empty; correct per VISION §3.1 ("if branch already in a slot: navigate there directly, no stash")
Result: PASS

## 2026-02-27T04-00-00Z

Location: ~/wt-usage-tests/2026-02-27T04-00-00/
Tests performed:
- BUG-030 fix verification — local-only repo (no remote), manually created branch in bare repo via `git --git-dir=.wt/repo branch feature/local-only main`; ran `wt checkout feature/local-only` — correctly printed ONLY "wt: Checked out feature/local-only in <slot>" with NO "Created local branch" line; BUG-030 fix (secondary `remoteBranchExists` guard) confirmed working for no-remote repos
- BUG-030 fix verification — with remote, branch exists in bare repo but NOT pushed to remote; confirmed `git ls-remote --heads origin local-only-not-on-remote` returns empty; ran `wt checkout local-only-not-on-remote` — no "Created local branch" message (correct); then ran `wt checkout remote-feature` (which IS on remote, first checkout) — correctly printed "wt: Created local branch remote-feature from origin/remote-feature"; both cases handled correctly
- `git worktree prune` then `wt list`: ran `git --git-dir=.wt/repo worktree prune` with all slot dirs intact — no-op, all 5 slots still present and listed correctly, exit 0; then deleted `hawk-pore-oval` slot dir, ran `git worktree prune` — removed the prunable registration; ran `wt list` — reconcile detected missing slot, ran `git worktree add` to create new vacant slot (`bolt-cairn-vapor`), maintaining 5-slot count; clean recovery from external worktree prune + slot deletion
- Deep nested branch name (`feat/team/user/component/sub-fix`, 4 slashes): `wt checkout` succeeded after `wt fetch` updated refs; "wt: Created local branch feat/team/user/component/sub-fix from origin/feat/team/user/component/sub-fix" printed correctly; eviction created stash metadata file `feat--team--user--component--sub-fix.toml` (slashes → double-dashes); `wt stash list` displayed truncated branch name correctly; `wt stash show feat/team/user/component/sub-fix` displayed full diff — 4-level deep branch name encoding/decoding works end-to-end
- Stash ref manually deleted while metadata TOML intact (adversarial GC scenario): ran `git --git-dir=.wt/repo update-ref -d refs/wt/stashes/feat--team--user--component--sub-fix` to delete the GC-protection ref; `wt stash list` still showed the entry (reads TOML, not the ref); `wt stash show` displayed the diff correctly (git accessed stash commit by SHA hash, not ref); `wt checkout feat/team/user/component/sub-fix` restored stash successfully ("Restored stash from just now"); conclusion: wt stash operations use the SHA from TOML metadata directly, so deleting the ref doesn't break anything until git prune/gc removes the unreferenced commit object — acceptable behavior
Result: PASS

## 2026-02-27T05:00:00Z

Location: ~/wt-usage-tests/2026-02-27T05-00-00/
Tests performed:
- `wt init` from a repo subdirectory (not root, VISION §2.1): created a git repo with a `src/` subdirectory; ran `wt init` from inside `src/` — correctly failed with "wt: Not at the root of a git repository. Run 'wt init' from the repository root (where .git/ lives), or use 'wt init <url>' to clone a new one." (exit 1); no partial state created; must run from where `.git/` lives
- Post-checkout hook: non-executable file (VISION §4.3): created `.wt/hooks/post-checkout` WITHOUT execute permission (`-rw-r--r--`); ran `wt checkout feature/hook-test` — checkout succeeded (exit 0), hook was NOT executed (verified by checking absence of log file the hook would have written); non-executable hooks are silently skipped, checkout is unaffected
- `wt list` sort order with pinned-in-place (Phase 1 §1.3): checked out 5 branches in sequence (main, alpha, beta, gamma, delta); pinned the beta slot (3rd oldest); re-ran `wt list` — beta appeared in its natural position (3rd), NOT promoted to the top; pin indicator visible in "Pinned" column but row position unchanged; pinned-in-place behavior confirmed; note: `wt list` CLI sort order is not specified in VISION.md (TUI WorktreePanel has "MRU first" per Phase 1 §1.3)
- `wt sync` with configured but non-existent shared directory (VISION §6): added `directories = ["configs"]` to `.wt/config.toml` but did NOT create `.wt/shared/configs/`; ran `wt sync` — exit 0, no output, no crash; `.wt/shared/configs/` was NOT auto-created; no symlinks created in slots; clean silent no-op when the canonical shared directory doesn't exist yet
- Fetch cooldown masks newly-pushed remote branch (Phase 1 §1.6): `wt init` does NOT set `last_fetch_at` (init clone is not recorded as a fetch) — first `wt checkout` after init always fetches; then set `last_fetch_at` to current time (simulating recent fetch); pushed `cooldown-test-branch` to remote AFTER last fetch; attempted `wt checkout cooldown-test-branch` within cooldown — received "wt: Branch 'cooldown-test-branch' not found locally or on remote." (exit 1), fetch correctly skipped by cooldown; then ran explicit `wt fetch` (bypasses cooldown, always runs) — fetched new branch ref; subsequent `wt checkout cooldown-test-branch` succeeded with "Created local branch cooldown-test-branch from origin/cooldown-test-branch" — fetch/cooldown recovery flow confirmed
Result: PASS

## 2026-02-27T06:00:00Z

Location: ~/wt-usage-tests/2026-02-27T06-00-00Z/
Tests performed:
- `wt init` twice in same directory: (a) `wt init <url>` from non-empty dir → "Directory is not empty. Use 'wt init' from inside an existing repository..." (exit 1); (b) `wt init` (no URL) from already-managed container → "This directory is already a wt-managed container." (exit 1); both cases correctly rejected with no partial state
- Symlink: git-tracked file takes precedence (VISION §6.3): added `configs/app.config` as a git-tracked file in `feature/alpha` branch; configured `[shared] directories = ["configs"]` with `.wt/shared/configs/app.config` as canonical; ran `wt sync` — emitted "wt: Skipping symlink for configs/app.config: file is tracked by git in branch feature/alpha." and left git-tracked real file intact; other slots (main, all vacant) received correct symlink `../../.wt/shared/configs/app.config` — git-tracked file wins over symlink exactly per §6.3
- Template source modification + sync regenerates all slots (VISION §7): created `.wt/templates/env.template` (source path is relative to `.wt/`), configured `[[templates]]` with `source = "templates/env.template"` and `target = ".env"`; first `wt sync` generated `.env` in all 5 slots with `BRANCH={{BRANCH_NAME}}` and `SLOT={{WORKTREE_DIR}}` expanded; vacant slots get `BRANCH=` (empty string); modified the template source to Version 2; second `wt sync` regenerated all slots with new content — template modification + sync always overwrites existing generated files; note: template source path is relative to `.wt/` (not the container root), using absolute or container-relative path gives "template source not found" error
- `wt clean` command (VISION §13): (a) with no archived stashes: "No archived stashes to clean." (exit 0); (b) with 1 archived stash (branch-to-archive.patch, 581 B): interactive two-step prompt — first "Select stashes to delete (comma-separated numbers, 'all', or 'none')", then "Delete 1 stash? [y/N]"; `printf "1\ny\n" | wt clean` → "Deleted 1 archived stash." (exit 0); patch file removed from `.wt/stashes/archive/`; stash no longer appears in `wt stash list`; 'none' input → "No valid selection. Aborted." (exit 0); full clean lifecycle verified
- Stash restore with merge conflicts after branch modification (VISION §5.2.1): created stash for `feature/conflict-test` (README.md changed to "CONFLICT-TEST LINE"); then added a new commit to `feature/conflict-test` that independently changed README.md to "DIFFERENT CONTENT THAT WILL CONFLICT"; checked out the branch — `wt` attempted stash restore, produced merge conflict; emitted "wt: Stash for feature/conflict-test produced conflicts. Resolve manually." and "Run 'wt stash drop feature/conflict-test' after resolution..."; conflict markers correctly set in README.md (`<<<<<<< Updated upstream` ... `>>>>>>> Stashed changes`); stash retained in `wt stash list` (not deleted); checkout completed with exit 0, user left in worktree to resolve — conflict behavior matches §5.2.1 exactly
Result: PASS

## 2026-02-27T10:00:00Z

Location: ~/wt-usage-tests/2026-02-27T10-00-00Z/
Tests performed:
- `wt clean` with multiple archived stashes and partial (comma-separated) selection (VISION §13): set up 3 active stashes (feature/alpha, feature/beta, feature/gamma) via dirty eviction; aged metadata to 8 days, deleted all 3 remote branches, ran `wt fetch` — all 3 archived ("Archived 3 stash(es): ..."); ran `printf "1,3\ny\n" | wt clean` — selected stashes 1 (feature/alpha) and 3 (feature/gamma); prompt asked "Delete 2 stashes? [y/N]"; confirmed with y → "Deleted 2 archived stashes." (exit 0); `wt stash list` showed only feature/beta (stash 2) still present; archive dir confirmed only feature--beta.patch remained — partial comma-separated selection works correctly
- `wt stash drop` while stash's branch is currently checked out in a slot (VISION §5.2.1): created dirty state (staged + unstaged + untracked) in feature/delta's slot; evicted it to create stash; re-checked out feature/delta with `--no-restore` (stash retained, slot clean); ran `wt stash drop feature/delta` from container root with `y` — "Stash dropped for 'feature/delta'." (exit 0); slot remained intact and clean; stash list showed no delta entry; stash drop is allowed regardless of whether branch is currently checked out — explicit user action, slot unaffected
- `wt sync` from inside a worktree slot directory (VISION §6, §7): configured `directories = ["configs"]` and `[[templates]]` for greeting.txt; ran `wt sync` from within `level-foam-prime/` (a slot, not container root) — container discovery walked up from slot dir to container; sync applied to ALL 5 slots (not just the one cwd was in); symlinks created correctly (`../../.wt/shared/configs/app.env`), templates expanded with slot-specific values (feature/delta branch in level-foam-prime, evict-test-* branches in other slots); exit 0 — `wt sync` works identically from any depth inside the container
- `slot_count = 1` extreme edge case (VISION §10): set slot_count to 1, ran `wt list` — 4 vacant slots evicted, only occupied main slot remained; dirtied main (unstaged + untracked); `wt checkout feature/delta` — evicted main (stash created), checked out feature/delta in only slot with "Created local branch feature/delta from origin/feature/delta"; `wt checkout main --no-restore` — evicted clean feature/delta (no stash), restored main; with only 1 slot every checkout evicts and stashes; stash lifecycle works correctly; exit 0 throughout
- `wt -` when MRU slot directory is deleted (VISION Phase 1 §1.9, adversarial): deleted level-foam-prime/ (MRU slot, feature/delta) from disk while state.toml still referenced it; ran `wt -` — reconcile detected missing slot, ran `git worktree add` to create new vacant slot `sharp-dew-slim`; `wt -` then skipped the new vacant slot and navigated to next MRU non-vacant slot (adder-wild-aloft, evict-test-6), printing "wt: Resuming evict-test-6 in adder-wild-aloft" (exit 0); wt list showed 5 slots with new vacant replacing deleted one; no crash, fully graceful recovery — deleted MRU slot triggers reconcile+fallback to next best
Result: PASS

## 2026-02-27T08:00:00Z

Location: ~/wt-usage-tests/2026-02-27T08-00-00Z/
Tests performed:
- `wt` commands from inside `.wt/` metadata directory (container discovery edge case): ran `wt list` from `.wt/` directly, then from `.wt/hooks/` subdirectory, then `wt checkout feature/stays-remote` from `.wt/` -- all commands succeeded; container discovery correctly walks up from inside `.wt/` to the parent container directory; exit 0, normal output in all cases
- Config with unknown/unrecognized keys (resilience): added `unknown_future_option = "some-value"`, `another_unknown_key = 42`, `[unknown_section]` with keys to `.wt/config.toml`; ran `wt list` and `wt checkout` -- both succeeded with exit 0, unknown keys silently ignored; known config fields (slot_count, archive_after_days, fetch_cooldown_minutes, shared.directories) applied correctly; no warning about unknown keys -- graceful forward/backward compatibility
- `wt stash list` with both active and archived stashes simultaneously: evicted `feature/stays-remote` (dirty, created active stash), evicted `feature/will-be-deleted` (dirty, created active stash), deleted `feature/will-be-deleted` from remote, aged stash `last_used_at` to 8 days ago, ran `wt fetch` -- stash archived; `wt stash list` showed both states in same table: `feature/stays-remote` (active) and `feature/will-be-deleted` (archived); display is clean with correct status labels for each row; mixed-state list renders correctly
- `wt checkout` of branch deleted from remote but still in bare repo refs/heads (ghost branch): after archiving `feature/will-be-deleted` stash (remote branch deleted, ref pruned from origin), bare repo still had `refs/heads/feature/will-be-deleted`; ran `wt checkout feature/will-be-deleted` -- checkout succeeded (branch found locally in bare repo), evicted `main` cleanly (no stash, clean slot), printed "wt: Archived stash for feature/will-be-deleted was not auto-restored. View with 'wt stash show feature/will-be-deleted'." then "wt: Checked out feature/will-be-deleted in warbler-shrill-pool"; `wt stash show feature/will-be-deleted` displayed full archived patch diff; ghost branch (remote-deleted, locally retained) is fully usable
Result: PASS

## 2026-02-27T11:00:00Z

Location: ~/wt-usage-tests/2026-02-27T11-00-00Z/
Tests performed:
- Corrupt `state.toml` (invalid TOML, not just empty): wrote `[slots.lagoon-otter-nymph\nbranch = "main"\n==== this is not valid TOML ====\n` to state.toml; ran `wt list` — printed "Warning: .wt/state.toml is corrupted. Regenerating from git state." to stderr, regenerated state from git worktree state with epoch timestamps and correct branch assignments, displayed all 5 slots correctly, exit 0; state.toml was rewritten with valid content; contrasts with corrupt config.toml (hard failure, exit 1) since state can be inferred from git but config cannot — corruption handling is asymmetric by design
- Pin all slots, then try checkout (VISION §11): filled all 5 slots with branches (main, feature/alpha, feature/beta, feature/gamma, feature/delta); pinned all 5 slots; attempted `wt checkout -b feature/epsilon` — received "wt: All worktree slots are pinned. Unpin a worktree or increase the slot count to continue." with exit 1; no eviction attempted, no slot state changed; actionable error message per VISION §11
- `wt stash show` on branch with no stash (VISION §5.2.1): with no stashes present (`wt stash list` → "No saved stashes."), ran `wt stash show main` — printed "wt: No stash found for branch 'main'." with exit 1; ran `wt stash show feature/nonexistent` — same error message and exit 1; consistent error handling for both "branch has no stash" and "branch doesn't exist in any slot" cases
- `wt` commands from completely outside any wt container (non-git empty directory): ran `wt list`, `wt checkout main`, `wt stash list`, `wt fetch`, `wt sync` from a temp directory with no `.git/` and no `.wt/` ancestor — all commands returned "wt: Not inside a wt-managed container." with exit 1; consistent, actionable error across all subcommands; no crash, no partial execution
- Manual `git worktree add` inside container, then `wt list` (reconciliation, VISION §15.1): manually created branch `feature/manual-branch` in bare repo with `git --git-dir=.wt/repo branch`; ran `git --git-dir=.wt/repo worktree add ./manual-wt-slot feature/manual-branch` (exit 0); ran `wt list` — reconcile picked up `manual-wt-slot` as a newly discovered slot (epoch timestamp); since total slots (6) exceeded slot_count (5), `adjustSlotCount` immediately evicted the LRU non-pinned slot (the manually-added one with epoch timestamp) — `manual-wt-slot` silently removed from disk and git registration; `wt list` output showed only the original 5 slots; no warning to user about the eviction of the manually-added slot; behavior is consistent with slot-count management logic (wt maintains configured slot count regardless of how slots appear)
Result: PASS
Result: PASS

## 2026-02-27T12:00:00Z

Location: ~/wt-usage-tests/2026-02-27T12-00-00Z/
Tests performed:
- Non-TTY detection (VISION §8): ran `node /workspace/bin/wt.mjs | cat` (piped, no TTY) from inside a managed container — printed "wt: TUI requires an interactive terminal. Use 'wt <command>' for CLI usage." with exit 0; no TUI rendering attempt, no crash; clean graceful fallback when stdout is not a TTY
- `wt checkout -b` on no-remote repo (VISION §3.0): (a) `wt checkout -b new-branch-no-remote` with no start point — failed with "wt: Could not detect remote default branch. No remote branches found." (exit 1) before any eviction; correct pre-validation behavior; (b) `wt checkout -b new-branch-from-main main` with explicit local branch as start point — succeeded in vacant slot, printed "wt: Created branch new-branch-from-main from main" (no spurious "origin/" prefix since there is no remote); both cases correct per VISION §3.0
- `wt list` with very long branch name: checked out `feature/very-long-branch-name/with/deep/nesting/and/extra/segments` (66 chars); `wt list` table correctly truncated the branch column to ~20 chars with `...` suffix: `feature/very-long...`; table layout was not disrupted; other columns (Slot, Status, Pinned, Last Used) retained correct alignment; no crash or overflow
- `wt stash apply` while MERGE_HEAD is present (adversarial, VISION §5.2.1): created stash for `main` via dirty eviction; re-checked out `main` with `--no-restore`; applied upstream changes to main; initiated a conflicting merge (`git merge origin/feature/short`) creating MERGE_HEAD state in the worktree slot; attempted `wt stash apply main` — git returned "error: could not write index" (index locked during merge); wt treated this as the conflict path: printed "wt: Stash for main produced conflicts. Resolve manually." and "Run 'wt stash drop main' after resolution..."; exit 0; stash retained in `wt stash list` (not deleted); graceful handling — stash is safe, user has actionable guidance, no crash
- `wt --version` and `wt --help` flags: `wt --version` prints `0.1.0` (exit 0); `wt --help` shows full command listing including all subcommands, aliases (co, ls), and `wt resume` plus `wt -` as resume aliases (exit 0); both standard yargs flags work correctly; `wt -` confirmed working as the resume shorthand from inside the container, navigating to MRU slot
Result: PASS

## 2026-02-27T13:00:00Z

Location: ~/wt-usage-tests/2026-02-27T13-00-00Z/
Tests performed:
- BUG-031 fix verification (VISION §2.2): ran `wt init http://not-a-real-git-repo.invalid/nonexistent.git` — clone failed with "fatal: unable to access ... Could not resolve host" (exit 128); confirmed `.wt/` was NOT left behind (directory empty); retried in same directory with valid file:// URL — `wt init <good-url>` succeeded with "Initialized with 5 worktree slots." (exit 0); cleanup-on-failure + retry-in-same-dir workflow fully functional
- Same-branch re-checkout (VISION §3): with feature/alpha in `glow-storm-wetland`, ran `wt checkout feature/alpha` again — printed "wt: Checked out feature/alpha in glow-storm-wetland" (exit 0); no eviction, no re-checkout, no duplicate "Created local branch" message; navigates to existing slot idempotently; stash was NOT auto-restored on re-checkout (stash had been applied earlier, none present — correct)
- `wt checkout --no-restore` then manual `wt stash apply` (VISION §3.1, §5.2.1): created dirty state (staged+unstaged README.md + untracked untracked.txt) on feature/alpha; forced eviction via checkout of feature/zeta — "Evicted feature/alpha from glow-storm-wetland (dirty state stashed)"; re-checked out feature/alpha with `--no-restore` — "wt: Checked out feature/alpha in slope-mild-wolf", "wt: Evicted feature/beta from slope-mild-wolf", no stash restored, no notification about available stash (per §3.2 spec: no such message is required); stash remained in `wt stash list`; ran `wt stash apply feature/alpha` manually — "Stash applied and cleaned up for 'feature/alpha'." (exit 0); after apply: ` M README.md` and `?? untracked.txt` restored; staging index partially lost in stash create/apply cycle (normal git behavior); full `--no-restore` → manual apply workflow confirmed
- `wt stash apply` on branch not in any slot (VISION §5.2.1): feature/zeta evicted with stash (from prior eviction), not in any active slot; ran `wt stash apply feature/zeta` — "wt: Branch 'feature/zeta' is not checked out in any slot. Run 'wt checkout feature/zeta' first." (exit 1); actionable error, no crash; stash preserved in stash list
- `wt pin` / `wt unpin` from worktree vs from container root (VISION §11): (a) `wt pin trunk-deer-log` from container root → "Pinned 'trunk-deer-log' (branch: feature/theta). It will not be evicted." (exit 0); (b) `wt pin` from within `slope-mild-wolf/` (no argument) → "Pinned 'slope-mild-wolf' (branch: feature/alpha)." (exit 0) — cwd-based pin works; (c) `wt unpin` by name and from within slot both work identically; (d) `wt pin nonexistent-slot` → "wt: Slot 'nonexistent-slot' not found." (exit 1); (e) `wt unpin trunk-deer-log` when already unpinned → "Slot 'trunk-deer-log' is not pinned." (exit 0, idempotent); (f) pin+unpin+eviction: after unpin, slot becomes evictable; LRU selects actual oldest slot (not the just-unpinned one) — correct ordering preserved
Result: PASS

## 2026-02-27T14:00:00Z

Location: ~/wt-usage-tests/2026-02-27T14-00-00Z/
Tests performed:
- Direct `git checkout` inside a slot, then `wt list` (reconciliation, VISION §15.1): checked out feature/alpha into `lapwing-lime-glen` via `wt checkout`; directly ran `git -C lapwing-lime-glen checkout feature/beta` (bypassing wt); ran `wt list` — reconcile silently updated state, slot now shows `feature/beta` instead of `feature/alpha`; no warning, no crash, state.toml corrected; matches VISION §15.1 requirement that direct git operations are detected and state updated silently
- Real file in shared slot directory + canonical already exists → `wt sync` migration (VISION §6.3): configured `[shared] directories = ["configs"]`; created canonical `.wt/shared/configs/app.env` (content: "from_canonical"); created REAL non-symlink file `far-pitch-cedar/configs/app.env` (content: "real_file_in_slot"); ran `wt sync` — slot file content was DISCARDED (rm'd, not moved to canonical since canonical already existed), symlink `far-pitch-cedar/configs/app.env → ../../.wt/shared/configs/app.env` created; canonical content preserved unchanged; all other 4 slots also received correct symlinks; consistent with symlinks.ts logic: canonical wins when it already exists, slot file silently dropped
- Delete canonical file in `.wt/shared/`, run `wt sync` → broken symlink cleanup (VISION §6.3): with all 5 slots having symlinks to `configs/app.env`; deleted `.wt/shared/configs/app.env`; ran `wt sync` — all 5 broken symlinks were removed from their respective slots (none left behind); exit 0, no output; matches VISION §6.3: "If a symlink is broken (target deleted), remove it."
- `wt stash drop` on archived stash (VISION §5.2.1, §12): set up active stash for feature/alpha (via dirty eviction); aged `last_used_at` to 8 days ago; deleted remote branch feature/alpha; ran `wt fetch` — stash archived ("Archived 1 stash(es): feature/alpha", "Warning: zstd not found. Archived stash stored uncompressed." patch file created); ran `printf "y\n" | wt stash drop feature/alpha` → "Stash dropped for 'feature/alpha'." (exit 0); post-drop: patch file `.wt/stashes/archive/feature--alpha.patch` deleted, metadata file `.wt/stashes/feature--alpha.toml` deleted; `wt stash list` → "No saved stashes."; full drop lifecycle for archived stash confirmed
- `wt shell-init fish` output (VISION §4.1): output uses fish-native syntax: `function/end` blocks, `set -l` for locals, `set -gx` for global export, `$fish_pid` (fish equivalent of `$$`), command substitutions with `( )`, `&&` chaining (fish 3.0+ syntax); exports `WT_SHELL_INTEGRATION=1`; uses `command wt` to bypass function (prevent recursion); nav file mechanism and post-checkout hook invocation present and syntactically correct; fish not installed in test env so runtime validation not possible, but manual review shows no syntax errors
Result: PASS

## 2026-02-27T15:00:00Z

Location: ~/wt-usage-tests/2026-02-27T15-00-00Z/
Tests performed:
- Template `{{BRANCH_NAME}}` expansion with special-character branch names (VISION §7): configured `[[templates]]` with source `templates/branch-info.txt` (content: `BRANCH={{BRANCH_NAME}}\nSLOT={{WORKTREE_DIR}}`); checked out `feature/v2.5` (slash + dot), `bugfix.123` (dot in name), `hotfix/2026-02-27@v1` (slash + digits + @); all three templates expanded correctly: `BRANCH=feature/v2.5`, `BRANCH=bugfix.123`, `BRANCH=hotfix/2026-02-27@v1`; branch names with `/`, `.`, `@`, `-`, digits all pass through verbatim into template output; note: template `source` path is relative to `.wt/` (not container root) — using `".wt/templates/..."` as the source triggers a double-join bug (path becomes `.wt/.wt/templates/...`); correct value is `"templates/..."` relative to `wtDir`; not a bug in the code but a potential source of user confusion
- Shared symlink incremental sync: new file added to canonical `.wt/shared/.secrets/` after initial sync (VISION §6.4): initial sync created `api.env` symlinks in all 5 slots; added second file `db.env` to canonical; re-ran `wt sync` — both `api.env` and `db.env` symlinks now present in all 5 slots; incremental propagation works correctly for newly-added canonical files
- Slot count decrease with all-occupied slots having stashes — stash persistence (VISION §10.1): filled all 5 slots; added tracked modifications in LRU slots (shore-chill-meadow/main: appended to README.md); decreased `slot_count` from 5 to 3 via direct config edit; ran `wt list` to trigger adjustment — 2 LRU slots (`shore-chill-meadow`, `kite-humid-wisp`) evicted with stashes created; stash list confirms `feature/v2.5` and `main` both present with `status: active`; slot directories gone; stash contents verified via `wt stash show main` (shows correct README.md diff); stash survives slot eviction as expected; later restore of `main` triggered a conflict because `branch-info.txt` (template-generated file, untracked) already existed in new slot — expected behavior per VISION §7 ("user responsible for gitignore"); `README.md` change correctly restored despite template conflict
- `wt stash drop` on archived stash — patch file deletion (VISION §12): created active stash for `feature/v2.5` (via slot count eviction); aged `last_used_at` to 2 weeks ago in TOML; deleted remote `feature/v2.5` branch; set `archive_after_days = 0`; ran `wt fetch` — stash archived: patch file `archive/feature--v2.5.patch` created, TOML `status` set to `archived` with `archive_path`; ran `printf "y\n" | wt stash drop feature/v2.5` from container dir → "Stash dropped for 'feature/v2.5'." (exit 0); post-drop: `archive/feature--v2.5.patch` deleted, `feature--v2.5.toml` deleted; `wt stash list` shows only `main`; full archived-stash drop lifecycle confirmed
Result: PASS

## 2026-02-26T08:40:38Z

Location: ~/wt-usage-tests/2026-02-26T08-40-38Z/
Tests performed:
- BUG-029 fix verification (VISION §3.2): checked out `remote-only` branch (never in branch_history) — "wt: Created local branch remote-only from origin/remote-only" printed correctly (exit 0); checked out same branch a second time — no "Created local branch" message (idempotent, already in branch_history); BUG-029 fix confirmed: using branch_history instead of refExists correctly detects first-time checkout
- BUG-030 fix verification (VISION §3.2): created `feature/local-only` directly in bare repo via `git --git-dir=.wt/repo branch feature/local-only main` (no remote); ran `wt checkout feature/local-only` — "wt: Checked out feature/local-only in low-silent-birch" with NO "Created local branch" line (exit 0); BUG-030 fix confirmed: remoteBranchExists check guards against false positives for locally-created branches and no-remote repos
- Post-checkout hook execution via shell integration (VISION §4.3): created `.wt/hooks/post-checkout` (executable `#!/bin/bash` script writing `"hook ran: worktree=$1 branch=$2"` to log file); ran `wt checkout remote-only` via bare binary — hook did NOT run (by design: hook is executed by shell function, not binary); sourced shell function via `eval "$(wt shell-init bash)"` and ran `wt checkout remote-only` through the shell function — hook ran correctly, log contained `"hook ran: worktree=.../ledge-log-shale branch=remote-only"`; shell function also cd-d to the worktree (cwd changed correctly); VISION §4.3 confirmed: hook receives $1 (absolute worktree path), $2 (branch name), runs in shell context after navigation
- `wt init <url>` into directory with single dotfile (VISION §2.2 edge case): created a directory with only `.gitconfig` (a single dotfile); ran `wt init <valid-remote-url>` — correctly rejected with "wt: Directory is not empty. Use 'wt init' from inside an existing repository, or run from an empty directory." (exit 1); no `.wt/` partial state created; dotfiles count as "non-empty" for the init check — any file in the directory blocks URL-based init
- Symlink appears/disappears based on git-tracked status per branch (VISION §6.3): configured `directories = ["shared-files"]` with `.wt/shared/shared-files/app.env` as canonical; ran `wt sync` — all 5 slots received `shared-files/app.env` SYMLINK except `feature/same-line-conflict` which has git-tracked `shared-files/app.env` ("wt: Skipping symlink for shared-files/app.env: file is tracked by git in branch feature/same-line-conflict."); branches without tracked file: SYMLINK → canonical; branch with tracked file: no symlink (real file or absent); `wt sync` correctly discriminates per-branch; note: edge case observed — if a slot has a symlink established from an older ref that pre-dates the branch adding a tracked file, the stash may capture the symlink as a "deletion" of the tracked file; after stash restore, `git status` shows `deleted: shared-files/app.env` even though the branch tracks it; this is an artifact of advancing a ref without going through wt checkout and does not represent a real-world regression
Result: PASS

## 2026-02-27T18:00:00Z

Location: ~/wt-usage-tests/2026-02-27T18-00-00Z/
Tests performed:
- Pin all slots (no vacant), then try checkout (VISION §11, §15.1): filled all 5 slots with branches (main, feature/alpha, feature/beta, feature/gamma, feature/delta), pinned all 5 slots, then ran `wt checkout feature/epsilon` — correctly printed "wt: All worktree slots are pinned. Unpin a worktree or increase the slot count to continue." (exit 1); no slot evicted, no state changed; matches VISION §15.1 exactly
- Decrease slot_count below pinned count (VISION §10.1): with all 5 slots pinned, set slot_count = 3 in config.toml, ran `wt list` — correctly printed "wt: Cannot reduce slot count to 3: 5 worktrees are pinned. Unpin worktrees first or choose a higher count." (exit 1); after restoring slot_count = 5, normal operation resumed; matches VISION §10.1 exactly
- Fetch cooldown (Phase 1 item 1.6): (a) ran `wt fetch` — executed and updated last_fetch_at; (b) immediately ran `wt checkout main` (within 10-minute cooldown) — checkout succeeded, last_fetch_at was NOT updated (fetch skipped silently); (c) manually set last_fetch_at to 20 min ago, ran `wt checkout feature/alpha` — fetch DID run, last_fetch_at updated; (d) ran `wt fetch` twice in a row — both executed and each updated last_fetch_at independently (explicit fetch always runs); cooldown behavior confirmed correct per Phase 1 spec
- Corrupt state.toml recovery (VISION §15.1): replaced state.toml with "THIS IS NOT VALID TOML !@#$%^&*()\nbroken = {unclosed" and ran `wt list` — printed "Warning: .wt/state.toml is corrupted. Regenerating from git state." then successfully showed all 5 slots with correct branch assignments (timestamps reset to epoch 1970-01-01); continued with `wt checkout main` — normal operation fully restored; graceful recovery confirmed
- `wt clean` command flow (VISION §5.5): (a) created dirty state in feature/gamma, evicted via LRU checkout to create active stash; (b) set stash created_at/last_used_at to 25 days ago (simulating old stash); (c) ran `wt fetch` — triggered archive scan: "Warning: zstd not found. Archived stash stored uncompressed." then "Archived 1 stash(es): feature/gamma" (no remote branch for gamma, age > 7 days); (d) ran `wt clean`: showed "Archived stashes: [1] feature/gamma (25d ago, 161 B)", prompt "Select stashes to delete (comma-separated numbers, 'all', or 'none'): "; entered "1" then "y" at confirmation prompt "Delete 1 stash? [y/N]" — printed "Deleted 1 archived stash." (exit 0); `wt stash list` returned "No saved stashes."; both metadata TOML and archive patch file removed; full stash lifecycle confirmed (active → archived → deleted)
Result: PASS

## 2026-02-26T09:00:00Z

Location: ~/wt-usage-tests/2026-02-26T08-59-58Z/
Tests performed:
- `wt stash` with no subcommand (yargs routing): ran `wt stash` from inside a managed container with no action argument — yargs printed usage showing valid choices (list/apply/drop/show) and "Not enough non-option arguments: got 0, need at least 1" with exit 1; clear and actionable, consistent with `wt hooks` no-arg behavior
- `wt unknowncmd` unknown subcommand (yargs routing): ran `wt unknowncmd` from inside container — yargs printed full command listing with all subcommands/aliases and "Unknown argument: unknowncmd" with exit 1; user sees all available commands in the error output
- `wt checkout v1.0` (git tag, not a branch): set up a remote with tag `v1.0` pushed; ran `wt checkout v1.0` — printed "wt: Branch 'v1.0' not found locally or on remote." (exit 1); tag exists in bare repo (`git tag -l` confirms) but `wt` correctly rejects it since `refs/heads/v1.0` does not exist and `ls-remote --heads origin v1.0` returns empty; tags are not branches and wt correctly refuses to check them out
- `wt init` on repo with pre-existing linked worktrees: created `extra-worktree` linked to `local-setup` via `git worktree add`; ran `wt init` from inside `local-setup` (which had the pre-existing linked worktree) — init succeeded (exit 0), 5 wt slots created, slot summary printed; however `extra-worktree/.git` (a gitdir pointer file) still points to old `local-setup/.git/worktrees/extra-worktree` path which no longer exists after `.git/` was moved to `.wt/repo/`; `git status` inside `extra-worktree` fails with "fatal: not a git repository: …/local-setup/.git/worktrees/extra-worktree"; the worktree metadata DID move to `.wt/repo/worktrees/extra-worktree/` correctly; `wt list` shows only the 5 managed slots; behavior is an expected consequence of git's absolute-path back-pointers: when `.git/` moves, existing linked worktrees lose their pointer; VISION §2.1 does not specify handling pre-existing worktrees; users should `git worktree remove` before `wt init`
- `wt list` output when piped (non-TTY stdout): ran `wt list | cat` — table rendered identically to interactive output with header row, separator line, and data rows; no format change, no missing data, exit 0; `wt list` does not detect non-TTY stdout and does not switch to a machine-readable format (consistent with VISION §8 which only specifies table format)
- `wt hooks` edge cases: (a) `wt hooks` with no args → yargs usage + "Not enough non-option arguments" (exit 1); (b) `wt hooks show` with no integration name → "wt: 'hooks show' requires an integration name (e.g., claude-code)" (exit 1); (c) `wt hooks show unknown-integration` → "wt: Unknown integration 'unknown-integration'. Supported: claude-code" (exit 1); (d) `wt hooks show claude-code` → valid JSON output (exit 0); all four cases handled cleanly with clear, actionable error messages
Result: PASS

## 2026-02-27T19-00-00Z

Location: ~/wt-usage-tests/2026-02-27T19-00-00Z/
Tests performed:
- `wt pin` / `wt unpin` with no arg from container root (not inside any slot): both correctly returned "wt: Not inside a worktree slot. Specify a slot name." with exit 1; error is clear and actionable; contrasts with `wt pin <slot-name>` which works from container root
- Unicode branch name end-to-end (`feature/résumé`): checkout succeeded with "wt: Created local branch feature/résumé from origin/feature/résumé" (exit 0); stash metadata file correctly named `feature--r%E9sum%E9.toml` (non-ASCII bytes percent-encoded, single-byte `%E9` for `é`); dirty eviction created stash correctly; `wt stash show feature/résumé` decoded the name and displayed full diff including staged and untracked files; re-checkout restored staged and untracked state correctly — full unicode branch lifecycle works
- `wt sync` when template target is a git-tracked file (VISION §7 "always overwrite"): `.env` was git-tracked (committed to main branch); configured `[[templates]]` with `target = ".env"`; ran `wt sync` — `.env` in active slot was overwritten with template-generated content; `git status` showed ` M .env`; VISION §7 "always overwrite, user responsible for gitignore" confirmed; template sync makes no exception for git-tracked target files
- `wt stash apply` / `wt checkout` after git GC prunes stash commit (adversarial): stash protection ref (`refs/wt/stashes/main`) manually deleted, then `git gc --prune=now` run — stash commit object pruned; `wt stash show main` → `fatal: '...' is not a stash-like commit` (exit 128, git error verbatim per §15.3); `wt checkout main` → branch successfully checked out but stash restore failure caused exit 128 and orphaned stash TOML in `.wt/stashes/`; `wt stash drop main` (recovery path) successfully removed orphaned TOML (exit 0); subsequent `wt checkout main` ran cleanly (exit 0); note: this requires manually bypassing protection refs + explicit `--prune=now` GC; automatic GC cannot prune these objects because the protection ref exists; not a realistic bug scenario
- Branch names with slash+digit patterns (`feature/test-5`, `feature/2026-hotfix`): both checked out correctly after `wt fetch` updated refs; "Created local branch" messages printed correctly; no yargs parsing confusion; numeric suffixes and date-like digit patterns in branch names work as expected
Result: PASS

## 2026-02-27T20:00:00Z

Location: ~/wt-usage-tests/2026-02-27T20-00-00Z/
Tests performed:
- `wt list` with all vacant slots: detached HEAD in all 5 slots, ran `wt list` — clean table showing "(vacant)" for all entries, exit 0; no crash, no empty-branch display errors; note: all vacant slots show "just now" (slots were just created at init, timestamps were epoch but displayed relative to creation); display handles all-vacant state gracefully
- Missing `state.toml` recovery (distinct from empty/corrupt): deleted `.wt/state.toml` entirely; ran `wt list` — silently regenerated from git worktree state (epoch timestamps), correct schema written including `branch_history = []`, no warning message (correct: missing file is not "corrupt"); subsequent `wt checkout main` succeeded (exit 0); note: because `branch_history` was reset by regeneration, re-checking out an existing branch (`main`) incorrectly showed "wt: Created local branch main from origin/main" — this is an observation, not a formal bug: the BUG-029 fix uses `branch_history` as a proxy for "first-time checkout" and deleting state.toml resets that history; only occurs in the adversarial scenario of manually deleting state.toml
- `wt stash apply/drop/show` with no argument from container root (not inside any slot): all three returned "wt: Not inside a worktree slot. Specify a branch name." (exit 1); consistent error handling for all three stash subcommands when cwd is not inside a managed slot; mirrors behavior of `wt pin`/`wt unpin` no-arg from container root
- `wt checkout -b` with dirty-state LRU eviction: filled all 5 slots, created staged + untracked dirty state in main (LRU slot); ran `wt checkout -b new-feature` (no start point) — evicted main from cairn-fern-holly ("wt: Evicted main from cairn-fern-holly (dirty state stashed)"), created new-feature from origin/main, checked out new-feature in cairn-fern-holly; stash for main verified: `wt stash list` showed entry, `wt stash show main` displayed both staged README.md change and untracked.txt; full `-b` workflow with eviction + stash working correctly end-to-end
- Concurrent `wt checkout` commands (locking mechanism): launched two concurrent checkouts in separate bash scripts (background `&`); first checkout succeeded (feature/alpha), second got "wt: Another wt operation is in progress. If this is stale, remove .wt/lock." (exit 1); no state corruption; lock file cleaned up by the first successful checkout; final `wt list` showed correct consistent state; locking correctly serializes concurrent mutations; stale lock test: manually created `.wt/lock` — all subsequent commands blocked with same message (exit 1); wt does NOT check if locking process is still alive; user must manually `rm .wt/lock` to recover from crashed operations; error message is clear and actionable
Result: PASS

## 2026-02-26T09:18:12Z

Location: ~/wt-usage-tests/2026-02-26T09-18-12Z/
Tests performed:
- `wt resume` (text command form, Phase 1 §1.9): confirmed `wt resume` works identically to `wt -`; from container root after checkout of remote-feature — "wt: Resuming remote-feature in nave-pool-large" with nav file written (exit 0); from within the MRU slot itself — "wt: Already in the most recently used worktree (remote-feature in nave-pool-large)" (exit 0, no-op); from outside any container (/workspace) — "wt: Not inside a wt-managed container." (exit 1); all three behaviors match `wt -` exactly — text alias fully functional
- Missing `.wt/stashes/` directory — `wt stash list` gracefully: deleted `.wt/stashes/` directory entirely; ran `wt stash list` — returned "No saved stashes." (exit 0); stash dir NOT auto-recreated (clean no-op); `wt stash show main` → "wt: No stash found for branch 'main'." (exit 1); `wt stash apply main` → same (exit 1); stash read operations handle missing dir gracefully with correct error messages
- Missing `.wt/stashes/` directory — dirty eviction crashes: with `.wt/stashes/` deleted and all 5 slots occupied, dirty main slot (modified README.md + untracked.txt) triggered for eviction; `wt checkout -b another-branch` returned "wt: ENOENT: no such file or directory, open '.../proj/.wt/stashes/main.toml'" (exit 1); raw Node.js error, no stash created, checkout did not complete — BUG-032
Result: BUG FOUND
Bug: BUG-032 — Missing `.wt/stashes/` directory causes raw ENOENT crash on dirty eviction

## 2026-02-27T22:00:00Z

Location: ~/wt-usage-tests/2026-02-27T22-00-00Z/
Tests performed:
- `wt checkout -b <branch> <tag>` as start point (VISION §3.3): ran `wt checkout -b new-from-tag v1.0` where `v1.0` is a git tag pushed to remote; checkout succeeded in vacant slot, printed "wt: Created branch new-from-tag from v1.0" (exit 0); branch SHA verified equal to tag SHA — tag as start-point works correctly; also tested pre-validation: `wt checkout -b should-not-exist v99.99` (nonexistent tag) → `fatal: Needed a single revision` (git error verbatim, exit 128), no slot evicted — pre-validation for bad tag ref fires correctly before eviction
- Duplicate `[[templates]]` entries with same `target` path (VISION §7): configured two `[[templates]]` blocks both writing to `.env`; ran `wt sync` — no error, exit 0; last template entry in config wins (overwrites output from first); all 5 slots had `.env` containing SOURCE=B (from second template), not SOURCE=A; consistent with VISION §7 "always overwrite" — sequential writes, last wins; no crash, no conflict detection
- `wt clean` with "all" keyword and 3 archived stashes (VISION §13): set up 3 archived stashes (feature/alpha, feature/beta, new-from-tag); ran `printf "all\ny\n" | wt clean` — listed all 3 with sizes, accepted "all" as selection, prompted "Delete 3 stashes? [y/N]", deleted all 3 on "y" ("Deleted 3 archived stashes.", exit 0); all 3 patch files removed from archive dir; non-archived stash (main) unaffected; "all" keyword correctly selects all archived stashes for bulk deletion
- `wt sync` with partial canonical state (VISION §6.3): configured `[shared] directories = ["configs"]` with 2 canonical files (`app.env`, `db.env`); first sync created both symlinks in all 5 slots; deleted `db.env` from canonical; second sync removed broken `db.env` symlinks from all slots while leaving valid `app.env` symlinks intact (exit 0); result is per-file granular cleanup — broken symlinks removed, valid symlinks untouched; all 5 slots updated correctly in single sync pass
- `wt init <url>` with empty remote (no commits, VISION §2.2): created bare repo with no commits; ran `wt init <empty-remote-url>` — git clone succeeded ("warning: You appear to have cloned an empty repository."); wt then failed to detect default branch: "wt: Could not detect remote default branch. No remote branches found." (exit 1); critically: `.wt/` was NOT left behind (BUG-031 fix covers the entire initFromUrl body in try/catch, not just the clone step, so cleanup fires for any failure including post-clone failures); directory clean for retry — BUG-031 fix handles all initFromUrl failure modes, not just clone failure
Result: PASS
## 2026-02-28T00:00:00Z

Location: ~/wt-usage-tests/2026-02-28T00-00-00Z/
Tests performed:
- Default branch not `main` (VISION §3.3): initialized `wt` from a bare remote where `symbolic-ref HEAD` = `refs/heads/develop` (not main); `wt init` correctly placed `develop` in the active slot ("active, branch: develop") and left 4 slots vacant; ran `wt checkout -b from-default-no-start` with no start point — printed "wt: Created branch from-default-no-start from origin/develop" (not origin/main); default branch detection correctly uses the remote's symbolic HEAD rather than assuming `main`; `wt checkout feature/new-feature` also printed "wt: Created local branch feature/new-feature from origin/feature/new-feature" — full non-main default branch workflow verified
- `wt checkout <sha>` — SHA instead of branch name (VISION §3.1): ran `wt checkout <full-40-char-sha>` — "wt: Branch 'bc35815b...' not found locally or on remote." (exit 1); ran `wt checkout <8-char-short-sha>` — same error (exit 1); both cases: clear error message, no eviction, no slot state change; wt correctly refuses SHAs — only branch names are accepted per VISION §3.1
- Epoch timestamps in `wt list` after state recovery (VISION §15.1): deleted `.wt/state.toml`; ran `wt list` — silently regenerated state from git worktree state; all 5 slots displayed with "20510d ago" (epoch 1970-01-01 relative to 2026-02-28 ≈ 56 years ≈ 20510 days); no crash, no "Invalid Date", no NaN; display is sensible if extreme; subsequent commands function normally — epoch timestamp display is safe
- `wt sync` with `.wt/shared/` directory entirely deleted (VISION §6.3): configured `[shared] directories = ["configs"]`, ran first sync — all 5 slots got `configs/app.env` symlinks; then deleted `.wt/shared/` entirely (rm -rf); ran `wt sync` again — all broken `configs/app.env` symlinks removed from all 5 slots (exit 0, no error output); `configs/` dirs remained (empty); `.wt/shared/` not auto-recreated; behavior identical to when individual canonical files are deleted — wt handles the entire shared dir being absent the same as missing individual canonical files
- Complete stash conflict recovery workflow (VISION §5.2, §5.2.1): (a) created dirty state (modified shared.txt + untracked.txt) in feature/conflict-test slot; (b) evicted via LRU to create stash; (c) manually advanced local `refs/heads/feature/conflict-test` to a commit with conflicting change to same file; (d) re-checkout produced conflict: "wt: Stash for feature/conflict-test produced conflicts. Resolve manually." and "Run 'wt stash drop feature/conflict-test' after resolution..." (exit 0); conflict markers visible in working tree (UU shared.txt, ?? untracked.txt); stash retained in `wt stash list`; (e) user resolved conflict manually and staged resolution; (f) ran `printf "y\n" | wt stash drop feature/conflict-test` — "Stash dropped for 'feature/conflict-test'." (exit 0); `wt stash list` → "No saved stashes."; `wt list` shows slot as "dirty" (expected: staged resolution not yet committed); complete end-to-end conflict recovery workflow verified
Result: PASS

## 2026-02-28T09:00:00Z

Location: ~/wt-usage-tests/2026-02-28T09-00-00Z/
Tests performed:
- BUG-032 fix verification -- `.wt/stashes/` auto-recreation during dirty eviction: deleted `.wt/stashes/` entirely with all 5 slots occupied and main slot dirty (modified README.md + untracked files); ran `wt checkout -b feature/new-test` -- triggered dirty eviction of main; `.wt/stashes/` was auto-created by the fix (`mkdir(stashesDir, { recursive: true })`); stash for `main` created and visible in `wt stash list`; exit 0; BUG-032 fix confirmed working
- Non-default `archive_after_days` config (VISION §5.3): set `archive_after_days = 14` in config; created a stash for `test-archive` (remote branch deleted); faked `last_used_at` to 10 days ago -> `wt fetch` did NOT archive (10 < 14 threshold); then faked to 15 days ago -> `wt fetch` DID archive ("Archived 1 stash(es): test-archive"); `archive_after_days` config correctly gates archival at the configured threshold (not hardcoded 7-day default)
- Ambiguous refname: branch AND tag both named `v2.0` (VISION §3.1): created branch `v2.0` in remote and pushed it, then created tag `v2.0` pointing to a different commit; `wt fetch` fetched both; `wt checkout v2.0` succeeded (exit 0) -- pre-validation saw `refs/heads/v2.0` in bare repo and `ls-remote --heads origin v2.0` returned the branch; however git in the worktree preferred the TAG (ambiguous refname behavior) causing HEAD detached at the tag SHA, not the branch tip; `wt` printed "Created local branch v2.0 from origin/v2.0" (incorrect -- worktree is detached); reconcile on next `wt list` correctly showed slot as `(vacant)` (detached HEAD -> vacant); observation only, not filed as bug (ambiguous branch/tag names are unsupported by git itself; very rare scenario)
- Missing `.wt/stashes/archive/` dir during `wt stash show` of archived stash: archived `test-archive` stash exists (TOML status=archived, archive_path set); deleted `.wt/stashes/archive/` dir; ran `wt stash show test-archive` -> "wt: ENOENT: no such file or directory, open '.../archive/test-archive.patch'" (exit 1); raw ENOENT, not a clean error message; `wt stash list` still works correctly (reads TOML, not archive dir); `wt stash drop test-archive` succeeds (exit 0, cleans up TOML even when archive file is gone); observation: `wt stash show` on archived stash emits raw ENOENT when archive dir/file is missing -- a minor UX rough edge but recoverable (drop works)
- BUG-032 fix extension -- `.wt/stashes/archive/` auto-creation during archival: had stash for `feature/archive-dir-test` (aged 20 days, remote branch not present); `.wt/stashes/archive/` did NOT exist; ran `wt fetch` -- archival triggered: "Warning: zstd not found. Archived stash stored uncompressed." then "Archived 1 stash(es): feature/archive-dir-test"; `.wt/stashes/archive/` auto-created, `feature--archive-dir-test.patch` written; `wt stash list` shows "archived" status; BUG-032 fix (`mkdir(archiveDir, { recursive: true })` before writing archive file) confirmed working for archive subdirectory too
Result: PASS

## 2026-02-28T14:00:00Z

Location: ~/wt-usage-tests/2026-02-28T14-00-00Z/
Tests performed:
- `wt init` from inside a managed slot without URL (VISION §2.1): ran `wt init` from inside `flat-grain-wide` — correctly printed "wt: Not a git repository root. Run 'wt init' from a regular git repository, not inside a worktree slot." (exit 1); no partial state created; clear, actionable error message ✓
- `wt init <url>` from inside a managed slot (non-empty dir): ran `wt init <url>` from inside `flat-grain-wide` — correctly printed "wt: Directory is not empty. Use 'wt init' from inside an existing repository, or run from an empty directory." (exit 1); no partial state created ✓
- `wt list` and `wt checkout` from inside `.wt/` directory (VISION §1): ran `wt list` from `.wt/` — container discovery correctly found the container (`.wt/` is a child of the container root, not a slot), listed all 5 slots; ran `wt checkout main` from `.wt/shared/` — correctly navigated to existing main slot; container discovery works from any subdirectory of the container including `.wt/` metadata dirs ✓
- Detached HEAD slot with dirty state — eviction behavior (VISION §3.1, §5.1): forced `flat-grain-wide` slot into detached HEAD via `git -C flat-grain-wide checkout --detach HEAD`; added dirty state (modified README.md + untracked.txt); `wt list` showed slot as `(vacant)` (detached HEAD = vacant); triggered eviction by checking out `br-e`; eviction message NOT printed (correct: vacant slot eviction is silent); no stash created for the detached slot (correct: no branch to stash for); dirty state carried over to new checkout (standard git behavior — git preserves unstaged changes when checking out new branch); slot shows as "dirty" after checkout; no data loss, no crash; vacancy check correctly suppresses stash for detached slots ✓
- `wt stash show` on missing archive patch file (VISION §15.3): archived stash for `br-d` (staged + unstaged + untracked dirty state); deleted `.wt/stashes/archive/br-d.patch`; ran `wt stash show br-d` — emitted raw ENOENT: "wt: ENOENT: no such file or directory, open '.../archive/br-d.patch'" (exit 1); raw Node.js error object exposed, not actionable — BUG-033
Result: BUG FOUND
Bug: BUG-033 — `wt stash show` emits raw ENOENT when archived stash patch file is missing

## 2026-02-28T12:00:00Z

Location: ~/wt-usage-tests/2026-02-28T12-00-00Z/
Tests performed:
- Branch name with `@` character (`feature@v2.0`) end-to-end (VISION §3.1, §5): set up remote with `feature@v2.0` branch; `wt checkout feature@v2.0` succeeded ("wt: Created local branch feature@v2.0 from origin/feature@v2.0", exit 0); `wt list` displayed `feature@v2.0` correctly; dirty eviction created stash metadata file `feature%40v2.0.toml` (@ encoded as %40) and git ref `refs/wt/stashes/feature%40v2.0`; `wt stash list` showed `feature@v2.0`; `wt stash show feature@v2.0` displayed full diff (staged + untracked); re-checkout restored stash correctly; `@` in branch names works end-to-end without issues
- Very long branch name (80+ chars) display and stash lifecycle (VISION §8, §5): checked out `feature/this-is-an-extremely-long-branch-name-exceeding-eighty-characters-total-width` (76 chars); `wt list` correctly truncated to `feature/this-is-a...` for display; stash TOML file stored at full name without truncation (`feature--this-is-an-extremely-long-branch-name-exceeding-eighty-characters-total-width.toml`); `wt stash list` truncated branch column with `...`; `wt stash show <full-name>` displayed diff correctly; `wt checkout <full-name>` restored stash; eviction message printed full untruncated name — long branch names work throughout the system, display truncation is purely cosmetic
- Container directory as symlink — container discovery (VISION §1): created `linked-project -> my-project` symlink; ran `wt list`, `wt stash list`, `wt checkout` from within `linked-project/` (the symlink) — all commands correctly found the container via the symlinked path; ran same commands from within `linked-project/pebble-rapid-crystal/` (slot dir accessed via symlink) — container discovery still worked; all operations succeeded with exit 0; container walk-up logic resolves symlinks correctly
- Multiple stashes (`wt stash list` with 5 entries) (VISION §5.2.1): accumulated 5 stashes for feature@v2.0, feature/alpha, feature/beta, feature/gamma, feature/this-is-...-long (via repeated dirty evictions); `wt stash list` displayed all 5 correctly, long branch names truncated with `...`, each showing correct base commit SHA; `wt stash show` for each returned the correct per-branch diff (no cross-contamination); `wt stash drop feature/beta` removed exactly one entry, leaving 4; final `wt stash list` confirmed correct state — multiple stashes coexist without interference
- `wt stash drop` no-arg from inside slot with stash (VISION §5.2.1): from within `firm-pond-deep` (feature/alpha), ran `wt stash drop` with no argument — defaulted to `feature/alpha`, prompted "Drop stash for 'feature/alpha'? This cannot be undone. [y/N]", dropped on `y`; remaining stash list unaffected (feature@v2.0, feature/gamma, feature/this-is-...-long); no-arg form works from within slot for drop
Result: PASS

## 2026-02-28T16:00:00Z

Location: ~/wt-usage-tests/2026-02-28T16-00-00Z/
Tests performed:
- BUG-033 fix verification (`wt stash show` on missing archived patch file): archived stash for `br-a` (staged + untracked dirty state); deleted `.wt/stashes/archive/br-a.patch`; ran `wt stash show br-a` — correctly printed "wt: Archived stash for 'br-a' patch file not found. The archive may have been deleted manually." and "wt: Run 'wt stash drop br-a' to clean up the stash metadata." with exit 1; no raw ENOENT; ran `wt stash drop br-a` — correctly cleaned up orphaned TOML metadata (exit 0); `wt stash list` showed "No saved stashes." — BUG-033 fix confirmed working ✓
- BUG-031 fix verification (`wt init <url>` cleanup on clone failure): ran `wt init http://not-a-real-repo-xyz.invalid/nonexistent.git` in empty dir — git printed "fatal: unable to access..." (exit 128); directory left completely clean (no partial `.wt/` directory created); retry with `wt init ../remote.git` succeeded and produced a full 5-slot container — BUG-031 fix confirmed working ✓
- `wt clean` with 3 archived stashes and partial selection `1,3` (VISION §13): archived 3 stashes (br-b, br-c, br-d); ran `wt clean` with input "1,3" then "y" — correctly listed all 3, selected stashes 1 (br-b) and 3 (br-d) for deletion, prompt showed "Delete 2 stashes?", deleted both; `wt stash list` confirmed only br-c remains; `.wt/stashes/archive/` contains only `br-c.patch`; ran `wt clean` with "all" then "y" on remaining 1 — "Deleted 1 archived stash.", list now empty; multi-selection and 'all' work correctly with 3+ archived stashes ✓
- Unknown/future keys in config.toml (forward-compatibility): added unknown top-level keys (`unknown_key_future_feature`, `another_unknown`), unknown key in `[shared]` section, and entire unknown section `[some_future_section]` to config.toml; ran `wt list` and `wt checkout` — both succeeded with exit 0, no warnings, correct output; unknown keys silently ignored; forward-compatibility design confirmed ✓
- `wt stash list` with mix of active and archived stashes (VISION §5.2.1): archived stash for `br-e` (20d ago, no remote) + active stash for `br-f` (just now); `wt stash list` displayed both in one table with correct Status column — `br-e` shows "archived" and 20d-ago age, `br-f` shows "active" and "just now" age; display format clearly distinguishes active vs archived, sorted by branch name; exit 0 ✓
Result: PASS
