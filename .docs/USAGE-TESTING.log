## 2026-02-25T09-00-00Z

Location: ~/wt-usage-tests/2026-02-25T09-00-00Z/
Tests performed:
- `wt init` run twice (URL variant): ran `wt init <url>` in an already-initialized container (non-empty directory) → "wt: Directory is not empty. Use 'wt init' from inside an existing repository, or run from an empty directory." (exit 1); correct per VISION §15.1 — PASS
- `wt init` run twice (no-URL variant): ran `wt init` (no URL) from container root of an already-managed container → "wt: This directory is already a wt-managed container." (exit 1); clean idempotent error — PASS
- `wt init` from inside a worktree slot: ran `wt init` from inside a wt slot (not a regular git repo root) → "wt: Not a git repository root. Run 'wt init' from a regular git repository, not inside a worktree slot." (exit 1) — PASS
- Manually `git worktree add` inside container then run `wt` commands: added git worktree at `container/manual-worktree` for feature/beta (on disk, registered in git); `wt list` absorbed it into state via reconcile (correct: dir exists AND registered) but then `adjustSlotCount` (5 slots→5 config) evicted it as LRU (epoch-0 last_used_at); manual-worktree directory deleted silently with no warning; subsequent `wt checkout feature/beta` succeeded in normal wt slot (loon-spray-oblique); container recovered cleanly — behavior is consistent with wt design (slot_count authoritative), though silent directory deletion could surprise users — PASS
- Pin all slots (all occupied) then checkout new branch: pinned all 5 slots; filled vacant pinned slots by checking out feature/gamma, feature/delta (pins don't prevent use of vacant slots per VISION §11); then with all 5 slots occupied+pinned, ran `wt checkout -b feature/epsilon` → "wt: All worktree slots are pinned. Unpin a worktree or increase the slot count to continue." (exit 1); correct per VISION §11 — PASS; also verified `wt checkout main` (already in slot) succeeded even with all slots pinned (navigates to existing slot, no eviction needed) — PASS
- Decrease slot_count below pinned count: with 5 slots all pinned, edited config to slot_count=3 → all subsequent commands (`wt list`, `wt checkout main`) failed with "wt: Cannot reduce slot count to 3: 5 worktrees are pinned. Unpin worktrees first or choose a higher count." (exit 1); error blocks ALL commands (adjustSlotCount runs early in every command); user must edit config.toml or unpin slots to recover; after restoring slot_count=5, commands worked normally; also verified: unpin 2 slots then reduce slot_count=3 → 2 LRU unpinned slots evicted, 3 pinned slots preserved correctly (exit 0) — PASS
Result: PASS

---

## 2026-02-25T07-00-00Z

Location: ~/wt-usage-tests/2026-02-25T07-00-00Z/
Tests performed:
- `wt checkout -b <branch>` creates a new branch from origin/main (Phase 2.4): ran `wt checkout -b feature/new-from-default` in a fresh container; branch created successfully, slot assigned (forest-frog-teal), feedback printed: "wt: Checked out feature/new-from-default in forest-frog-teal" + "wt: Created branch feature/new-from-default from origin/main"; new branch had correct file content (file1.txt, file2.txt from main); exit 0 — PASS
- `wt checkout -b <branch> <start-point>` creates from explicit start point: ran `wt checkout -b feature/from-develop origin/develop`; branch created in ruby-round-carp; feedback: "Checked out feature/from-develop in ruby-round-carp" + "Created branch feature/from-develop from origin/develop"; slot directory contained develop.txt (develop branch content), confirming correct start point; exit 0 — PASS
- `wt checkout -b <branch>` when branch already exists: ran `wt checkout -b main` (branch exists); git printed "fatal: a branch named 'main' already exists" (correct, verbatim); then wt ALSO printed "wt: Command failed with exit code 128: git checkout -b main origin/main" — this is extra wrapping on top of the git error; violates VISION "git errors pass through verbatim" — BUG FOUND
Result: BUG FOUND
Bug: BUG-019 — Git errors double-printed; ExecaError message appended after git stderr already displayed via inherit (see .docs/BUGS.md)

---

## 2026-02-25T06-07-14Z

Location: ~/wt-usage-tests/2026-02-25T06-07-14Z/
Tests performed:
- `WT_SHELL_INTEGRATION=1` suppresses shell hint on `wt init`: ran `wt init <url>` with `WT_SHELL_INTEGRATION=1` set — output showed slot summary but NO shell integration hint (hint omitted correctly); re-ran without env var — hint appeared as expected. Phase 2.2 detection works correctly. — PASS
- Template with malformed variable syntax: created template with `{{BRANCH_NAME` (no closing `}}`), `{{BRANCH_NAME}` (one closing `}`), `{{UNKNOWN}}` (unknown variable), and `{{BRANCH_NAME}}` (valid); ran `wt sync`; result: `{{BRANCH_NAME` and `{{BRANCH_NAME}` passed through literally (no crash, no error), `{{UNKNOWN}}` passed through literally, `{{BRANCH_NAME}}` expanded correctly to branch name. Template expansion gracefully handles malformed variables by leaving them as-is. — PASS
- Untracked symlinks in dirty state survive stash/restore cycle: created dirty state in slot (staged tracked change to README.md + untracked symlink `readme-link.txt -> README.md` + untracked file `untracked.txt`); evicted slot via checkout of new branch with all 5 slots full; verified stash captured symlink as git mode 120000; restored stash via re-checkout of branch; verified `readme-link.txt -> README.md` is a valid symlink in restored slot, untracked file content preserved, staged change content preserved in working tree. Note: staged vs. unstaged state not fully preserved (staged change became unstaged after `git stash apply` without `--index`) — this is pre-existing behavior. — PASS (symlink preserved; staged-state loss is known behavior)
- Partial state.toml (valid TOML but missing required fields): removed `branch` field from one slot entry and `last_used_at` from another; ran `wt list` — missing `branch` recovered from actual git state via reconciliation (correct branch shown), missing `last_used_at` defaulted to epoch 0 ("20509d ago"), no crash; ran checkout of new branch — slot with missing `last_used_at` (epoch 0) correctly selected as LRU eviction candidate. Graceful degradation confirmed. — PASS
Result: PASS

---

## 2026-02-23T14-38-59Z

Location: ~/wt-usage-tests/2026-02-23T14-38-59Z/
Tests performed:
- Removing shared directory from config then running `wt sync` (orphan symlink behavior): configured `[shared] directories = [".config", ".tools"]`, synced (all 5 slots got correct symlinks for both dirs); removed `.tools` from config (now only `[".config"]`), re-ran `wt sync`; `.config` symlinks maintained correctly; `.tools` symlinks persisted as orphans (still valid — canonical file exists); deleted canonical `.wt/shared/.tools/lint.json` to make orphan symlinks broken; re-ran `wt sync` — broken `.tools` symlinks NOT cleaned up (sync only processes configured directories); `.config` symlinks unaffected. Behavior is consistent with VISION §6.4 (sync scans "all configured shared directories") — no cleanup defined for de-configured directories. Edge case noted: removing a directory from config leaves orphan symlinks that must be manually cleaned. — PASS (edge case noted)
- `wt` commands from inside `.wt/` metadata directory: ran `wt list` from `.wt/` (container root's metadata dir) — correct output, exit 0; `wt checkout feature/alpha` from `.wt/` — succeeded, slot assigned correctly; `wt checkout feature/beta` from `.wt/repo/` (bare repo subdirectory) — succeeded, slot assigned correctly; `wt list` from `.wt/stashes/` — correct output; `wt pin` / `wt unpin` from `.wt/stashes/` — both succeeded with correct messages. Container detection correctly walks up from `.wt/` subdirectories to find the container root. — PASS
- File permissions (executable bit) preserved through stash/restore roundtrip: created executable `my-script.sh` (755, untracked), non-executable `data.json` (644, untracked), and modified tracked `src/index.js` (755) in main slot; evicted main via LRU; `wt stash show main` confirmed modes preserved in diff (`new file mode 100755` for script, `100644` for data); re-checked out main into same slot; permissions exactly preserved: `my-script.sh` 755, `data.json` 644, `src/index.js` 755; all file contents correct — PASS
- Local-only branch (never on remote) through full stash lifecycle: created `local-only-experiment` branch directly in bare repo via `git branch`; `wt checkout local-only-experiment` succeeded (exit 0), slot assigned correctly; created dirty state (untracked `experiment.txt` + modified `file1.txt`); evicted via LRU manipulation; `wt stash show local-only-experiment` confirmed both files captured; re-checked out `local-only-experiment` — stash auto-restored; `experiment.txt` content correct ("local experiment WIP"), `file1.txt` modification intact; stash cleaned up after successful restore. Full lifecycle works for branches that exist only locally and have no remote tracking. — PASS
Result: PASS

---

## 2026-02-23T14-31-51Z

Location: ~/wt-usage-tests/2026-02-23T14-31-51Z/
Tests performed:
- Checkout to branch already in another slot when current slot is dirty: filled 5 slots (main in gross-bleak-plain, feature/alpha in dace-quiet-marten); created dirty state in main slot (`A wip-dirty.txt`, `M file1.txt`); ran `wt checkout feature/alpha` from main slot; exit 0, nav file written pointing to dace-quiet-marten (alpha slot); main slot dirty state preserved untouched (`A wip-dirty.txt`, `M file1.txt` still present); no eviction, no stash created; `wt list` showed main slot as "dirty" — correct per VISION §3.1 step 3 (navigate to existing slot, no touch on source slot) — PASS
- Rapid sequential checkouts affecting LRU ordering: filled all 5 slots (main, alpha, beta, gamma, delta); performed checkout sequence alpha→beta→gamma→alpha→delta→beta (each navigating to existing slot); then checkout feature/epsilon (new branch, forces eviction); main (gross-bleak-plain) was correctly identified as LRU (never revisited during the sequence); main's dirty state (`wip-dirty.txt` + modified `file1.txt`) was stashed; epsilon checked out in evicted slot; `wt stash show main` confirmed both files — LRU tracking across rapid sequential checkouts is correct — PASS
- wt sync with mixed real files and symlinks across multiple shared directories: configured `[shared] directories = [".tools", ".env.d"]` with 4 canonical files; created real (non-symlink) files in 2 slots (dace-quiet-marten/.tools/formatter.json with different content, moose-cold-prime/.env.d/db.env with different content); ran `wt sync`; all 5 slots received all 4 files as symlinks to canonical copies; canonical files retained their original content (authoritative); real files in slots replaced with symlinks — correct per VISION §6.4 — PASS
- Stash with deleted git ref but existing metadata (corrupted stash): deleted `refs/wt/stashes/main` ref via `git update-ref -d` while keeping `.wt/stashes/main.toml` metadata intact; `wt stash list` still showed the stash (reads from metadata); `wt stash show main` displayed correct diff (git object still in store, hash referenced directly); `wt checkout main` successfully applied stash and restored dirty state (`A wip-dirty.txt`, `M file1.txt` both present with correct content); stash cleaned up after successful restore — resilient to deleted refs as long as git objects not GC'd — PASS
- Full stash archive lifecycle (create → archive → show → drop): created dirty state in feature/alpha slot (alpha-wip.txt untracked + file1.txt modified); evicted via checkout feature/zeta; stash created with both files (shared symlinks excluded per BUG-007 fix); faked `last_used_at` to 10 days ago; deleted feature/alpha from remote; `wt fetch` triggered archival — "Archived 1 stash(es): feature/alpha" with "Warning: zstd not found" (expected in test env); archived patch file at `.wt/stashes/archive/feature--alpha.patch` contained both tracked changes AND untracked files with `# --- untracked files ---` separator (BUG-014 fix confirmed); `wt stash show feature/alpha` on archived stash displayed patch contents (BUG-014 secondary fix confirmed); `printf 'y\n' | wt stash drop feature/alpha` dropped with confirmation; complete cleanup verified: metadata TOML deleted, archive patch deleted, git ref gone, `wt stash list` empty — PASS
Result: PASS

---

## 2026-02-23T14-19-16Z

Location: ~/wt-usage-tests/2026-02-23T14-19-16Z/
Tests performed:
- Shared symlink toggle on branch switch (git-tracked ↔ untracked): configured `[shared] directories = [".config"]` with canonical `.config/app.json`; `wt sync` correctly skipped symlinks for all slots (all on commits where `.config/app.json` is git-tracked); checked out `feature/no-config` (deleted `.config/app.json` from tree) into `low-wetland-lean` — symlink created correctly (`lrwxrwxrwx -> ../../.wt/shared/.config/app.json`), content from canonical file; checked out `feature/tracks-config` (has `.config/app.json` tracked) into `hushed-lone-grand` — regular file, NOT symlink, content `{"app":"tracked-version"}` (git-tracked version), warning "Skipping symlink... tracked by git" printed; re-checked out `feature/no-config` — symlink reappeared in `low-wetland-lean`. Full round-trip: symlink appears when file not tracked, disappears when tracked, reappears when switching back — correct per VISION §6.3 — PASS
- Stash with ONLY untracked files (no tracked changes): created 3 untracked files (including nested `new-dir/nested.txt`) in `feature/alpha` slot with zero staged/unstaged tracked changes; evicted alpha via LRU; `wt stash show feature/alpha` confirmed all 3 files captured in stash diff; re-checked out `feature/alpha` into different slot (`wren-dim-verge`); all 3 files restored with correct content; `git status --short` showed `?? new-dir/`, `?? untracked1.txt`, `?? untracked2.txt`; stash cleaned up — untracked-only stash survives full save/restore roundtrip — PASS
- Re-eviction of slot with unresolved merge conflicts: created stash for `feature/rebase-test` at commit `ee144b4` (dirty: modified `shared-file.txt` + untracked `re-eviction-test.txt`); force-pushed remote branch to new commit `bafd1d1` (different `shared-file.txt` content); updated local branch; checkout `feature/rebase-test` triggered stash apply with merge conflict (`UU shared-file.txt` with `<<<<<<< Updated upstream` markers); stash retained as expected per VISION §15.2; then attempted `wt checkout feature/epsilon` which tried to evict the conflicted slot — `git stash push --include-untracked` FAILED with "error: could not write index" / "shared-file.txt: needs merge" (exit 1); checkout blocked — BUG FOUND
Result: BUG FOUND
Bug: BUG-016 — Eviction fails when slot has unresolved merge conflicts from stash apply; `git stash push` cannot handle unmerged index entries, blocking all subsequent checkouts that would evict the conflicted slot (see .docs/BUGS.md)

---

## 2026-02-23T14-13-07Z

Location: ~/wt-usage-tests/2026-02-23T14-13-07Z/
Tests performed:
- Corrupt config.toml (invalid TOML syntax): wrote garbage to .wt/config.toml; `wt list` → "wt: Invalid TOML document: incomplete key-value: cannot find end of key" (exit 1); `wt checkout feature/alpha` → same clean error (exit 1); `wt fetch` performed the fetch successfully but then failed on archive scan with same error (exit 1); no crash, no stack trace. With wrong-type config (`slot_count = "not a number"`), `wt list` succeeded (exit 0) using default values silently — robust fallback behavior — PASS
- wt init from URL to empty bare repo (no commits, no branches): `wt init file:///path/to/empty-remote.git` → bare clone succeeded (with git warning "empty repository"), then "wt: Could not detect remote default branch. No remote branches found." (exit 1); clean error message, no crash, no stack trace; .wt/ directory partially created (repo/ exists but no config.toml, state.toml, or slots) — minor cleanup gap but error is clean — PASS
- Checkout from inside a subdirectory of a slot: ran `wt checkout feature/alpha` from `ember-frond-lark/src/` (subdirectory); checkout succeeded (exit 0), feature/alpha assigned to vacant slot `slate-wetland-short`; nav file correctly pointed to slot root (not subdirectory); via shell function (`eval "$(wt shell-init bash)"`), checkout from subdirectory correctly changed CWD to target slot root — PASS
- Manual deletion of stash metadata with orphaned git ref: created stash for main (dirty state: wip-main.txt + modified file1.txt); manually deleted `.wt/stashes/main.toml` leaving `refs/wt/stashes/main` ref intact; `wt stash list` → "No saved stashes." (exit 0); `wt stash show main` → "No stash found for branch 'main'." (exit 1); `wt checkout main` succeeded (exit 0) but dirty state silently lost (no metadata to trigger restore); orphaned git ref persists (minor resource leak); no crash, all operations clean — PASS (expected behavior when user manually deletes metadata)
- Eviction after direct git checkout in slot (reconciliation + eviction interaction): directly ran `git checkout feature/alpha` inside `olive-cloud-dry` slot (was on feature/beta, bypassing wt); created dirty state (direct-wip.txt untracked + file1.txt modified); `wt list` correctly detected branch change to feature/alpha and dirty status via reconciliation; manipulated LRU timestamps to make olive-cloud-dry the eviction candidate; `wt checkout feature/beta` evicted olive-cloud-dry, stash created for feature/alpha with both files; `wt stash show feature/alpha` confirmed both dirty files; re-checked out feature/alpha into different slot (ember-frond-lark); both files fully restored (direct-wip.txt content + file1.txt modifications intact); stash cleaned up — full reconciliation → eviction → stash → restore roundtrip correct — PASS
Result: PASS

---

## 2026-02-23T14-07-30Z

Location: ~/wt-usage-tests/2026-02-23T14-07-30Z/
Tests performed:
- Binary file preservation through stash/restore roundtrip: created binary file (14 bytes, null bytes + PNG magic) and special-chars file (46 bytes, tabs + embedded nulls) as untracked in main slot; evicted main via LRU; `wt stash show main` confirmed both files in stash (shown as "Binary files differ"); re-checked out main into different slot (stork-knoll-slim); md5sums matched exactly (8696568ce69c9aa494e1d1a0041bca94, 2ac61f4629cd968c24a52d0195f1da0b); byte counts identical; stash cleaned up after successful restore — binary data survives full stash/restore roundtrip — PASS
- Double eviction with --no-restore (stash overwrite): checked out feature/alpha, created eviction1.txt (untracked), evicted (stash 1 created); re-checked out feature/alpha with --no-restore (stash preserved, eviction1.txt NOT in working tree); added eviction2.txt + modified file1.txt; evicted again (stash 2 created); `wt stash show feature/alpha` showed only eviction2.txt + modified file1.txt — eviction1.txt from first stash silently lost; one stash per branch, second eviction replaces first; no warning shown — PASS (architecturally correct per one-stash-per-branch design, but silent data loss is notable; user chose --no-restore)
- Config slot_count=0 edge case: set slot_count=0 in config.toml; `wt list` evicted all 5 slots, showed header with no rows (exit 0); stashes created for 2 dirty slots (main, feature/alpha); `wt checkout main` → "All worktree slots are pinned" (exit 1) — error message misleading (0 slots, not "all pinned"); restored slot_count=5; 5 new vacant slots created automatically; stashes still available for later restore — PASS (functionally correct, UX edge case with misleading error message)
- Slot directory emptied but not deleted (partial corruption): emptied vault-lofty-dark contents via `rm -rf vault-lofty-dark/*` (directory still exists, .git file gone); `wt list` showed slot as "(vacant)" (correct detection); `wt checkout feature/beta` failed: "fatal: not a git repository" (exit 1); tried 3 different branches — ALL failed with same error; wt always selects the corrupted slot despite 3 healthy vacant slots being available; container stuck, no new checkouts possible — BUG FOUND
Result: BUG FOUND
Bug: BUG-015 — Slot with emptied directory (missing .git file) blocks all checkouts; corrupted slot always selected over healthy vacant slots (see .docs/BUGS.md)

---

## 2026-02-23T13-54-27Z

Location: ~/wt-usage-tests/2026-02-23T13-54-27Z/
Tests performed:
- Branch names with dots (`release/v2.0.1`): checked out from remote, slot assigned (hart-kite-open), `wt list` showed correct branch name, branch-specific file (release-v2.0.1.txt) present in slot — correct per VISION §14 (dots are valid in filenames, no encoding needed) — PASS
- Branch names with `#` (`hotfix/issue#42`): checked out from remote, slot assigned (frost-spur-verge), files present; created dirty state (hotfix-wip.txt untracked + file1.txt modified); forced eviction via LRU manipulation; stash metadata file encoded as `hotfix--issue%2342.toml` (correct: `/` → `--`, `#` → `%23` per VISION §14); `wt stash show hotfix/issue#42` displayed both dirty files; re-checkout restored all dirty state; stash cleaned up — full roundtrip correct — PASS
- `wt stash show` on archived stash (BUG-014 secondary issue): archived hotfix/issue#42 stash (faked timestamp + deleted remote branch + `wt fetch`); `wt stash show hotfix/issue#42` displayed patch file contents (tracked modifications + untracked files including `# --- untracked files ---` separator); exit 0 — BUG-014 fix correctly addressed both primary issue (untracked capture) and secondary issue (archived stash display) — PASS
- Archive scan timing — remote deleted but recent use: created feature/alpha stash with fresh `last_used_at`, deleted remote branch, ran `wt fetch`; stash remained active (NOT archived) — correct per VISION §5.3 (both conditions must be met: remote deleted AND last_used_at > archive_after_days) — PASS
- Archive scan timing — old use but branch on remote: faked feature/alpha `last_used_at` to 13 days ago, re-created feature/alpha on remote, ran `wt fetch`; stash remained active (NOT archived) — correct per VISION §5.3 — PASS
- Archive scan timing — both conditions met: deleted feature/alpha from remote again (with already-old timestamp), ran `wt fetch`; stash correctly archived — confirms archival requires BOTH conditions — PASS
- Checkout nonexistent branch: `wt checkout totally-nonexistent-branch-xyz` → git error passed through verbatim ("error: pathspec 'totally-nonexistent-branch-xyz' did not match any file(s) known to git"), exit 1; target slot correctly reverted to vacant state (detached HEAD), no corruption; subsequent checkouts succeeded — correct per VISION §15.3 — PASS
- Staged vs unstaged distinction preserved through eviction+restore: created three categories of dirty state in main slot (staged new file `A  new-staged.txt`, unstaged modification ` M file1.txt`, untracked `?? untracked.txt`); evicted main via LRU; re-checked out main into different slot; `git status --short` showed identical flags (`A  new-staged.txt`, ` M file1.txt`, `?? untracked.txt`); all file contents correct — staged/unstaged/untracked distinction perfectly preserved — PASS
Result: PASS

---

## 2026-02-23T13-42-08Z

Location: ~/wt-usage-tests/2026-02-23T13-42-08Z/
Tests performed:
- Eviction with only staged changes (no unstaged/untracked): staged a new file (staged-only.txt) in main slot, no unstaged or untracked files; filled all 5 slots, manipulated LRU ordering, forced eviction of main via checkout of feature/eta; stash created; `wt stash show main` confirmed staged-only.txt captured; re-checked out main into different slot (spar-lake-deer); staged-only.txt restored AND still in staging area ("Changes to be committed"); stash cleaned up — correct per VISION §5.1 and §5.2 — PASS
- Archive stash with untracked files — data loss bug: evicted main again (now with staged-only.txt staged + archive-test-file.txt untracked); stash created with 3 parents (confirmed third parent contains archive-test-file.txt via `git ls-tree`); faked last_used_at to 13 days ago, deleted main from remote, ran `wt fetch`; archival triggered; BUT archived patch file `.wt/stashes/archive/main.patch` only contains staged-only.txt — archive-test-file.txt (untracked) is MISSING; root cause: `git diff --binary <commit> <stash_ref>` does not capture untracked files from stash's third parent — BUG FOUND
- Secondary: `wt stash show` on archived stash returns "Stash is archived. Cannot show diff from archived stash." (exit 1); since the patch file IS the diff, this should be displayable
Result: BUG FOUND
Bug: BUG-014 — archiveStash loses untracked files; `git diff --binary` does not capture stash third parent (see .docs/BUGS.md)

---

## 2026-02-23T25-00-00Z

Location: ~/wt-usage-tests/2026-02-23T25-00-00Z/
Tests performed:
- Template with unknown `{{UNKNOWN_VAR}}` variable (retry after BUG-013 fix): configured `[[templates]]` with source containing `{{WORKTREE_DIR}}`, `{{BRANCH_NAME}}`, and `{{UNKNOWN_VAR}}`; `wt sync` succeeded (exit 0); all 7 slots got generated `.env.local`; `{{WORKTREE_DIR}}` expanded to slot name, `{{BRANCH_NAME}}` expanded to branch (empty for vacant), `{{UNKNOWN_VAR}}` left as literal string `{{UNKNOWN_VAR}}`; no error, no crash — reasonable behavior since vision §7.2 only defines two variables; checkout also regenerated template correctly with branch-specific values — PASS
- `wt init <url>` into directory with a single dotfile: created directory with `.hidden` file, ran `wt init file://...`; exit 1, "wt: Directory is not empty. Use 'wt init' from inside an existing repository, or run from an empty directory." — correct per VISION §15.1; confirmed truly empty directory succeeds — PASS
- Slot count increase with templates configured: changed slot_count from 5 to 7 in config.toml; `wt list` triggered reconciliation, created 2 new vacant slots with "Preparing worktree" messages; new slots received template-generated `.env.local` with correct `WORKTREE=<new-slot-name>`, empty `BRANCH=`, and literal `{{UNKNOWN_VAR}}`; reconciliation correctly runs template generation for new slots — PASS
- `wt checkout` of branch already checked out from different slot: feature/alpha already in pure-trunk-swamp; ran `wt checkout feature/alpha` from flame-ruff-short (main); exit 0, no eviction, main slot unchanged; nav file written pointing to pure-trunk-swamp (the existing feature/alpha slot); `wt list` confirmed no slot changes — correct per VISION §3.1 step 3 (navigate to existing slot) — PASS
- Eviction+restore cycle with templates configured: filled all 7 slots; added real dirty state to main slot (flame-ruff-short): modified file1.txt + untracked wip-main.txt + template-generated .env.local; forced eviction via `wt checkout feature/eta`; stash created for main containing all 3 files (including .env.local with WORKTREE=flame-ruff-short); re-checked out main into pure-trunk-swamp (different slot); all user files restored (wip-main.txt, modified file1.txt); .env.local regenerated with WORKTREE=pure-trunk-swamp (new slot name, not stashed old name) — template "always overwrite" (VISION §7.1) correctly overwrites stashed template content; stash cleaned up after successful restore — PASS
Result: PASS

---

## 2026-02-23T13-27-42Z

Location: ~/wt-usage-tests/2026-02-23T13-27-42Z/
Tests performed:
- wt init from repo in detached HEAD state: cloned remote, ran `git checkout --detach HEAD`, then `wt init`; init succeeded (exit 0), 5 slots created, all vacant — no starting branch recorded because HEAD was detached; `wt list` showed 5 vacant slots; no slot checked out to any branch; user would need `wt checkout main` to start working — not a crash, but vision §2.1 step 5 ("Check out the starting branch in one slot") was silently skipped; arguable edge case, not filed as bug since vision doesn't explicitly address detached HEAD init — PASS (marginal)
- wt checkout of a tag name (v1.0.0): `wt checkout v1.0.0` on initialized container; exit 0; a vacant slot (ruby-rind-grim) was selected, git detached at tag commit; `wt list` showed slot as "(vacant)" because detached HEAD ≠ branch; state.toml recorded "v1.0.0" in branch_history but slot has no branch field; nav file pointed to correct slot; behavior is reasonable for branch-centric tool — PASS (edge case noted)
- Template with unknown `{{UNKNOWN_VAR}}` variable: configured `[[templates]]` with source containing `{{UNKNOWN_VAR}}` alongside `{{WORKTREE_DIR}}` and `{{BRANCH_NAME}}`; COULD NOT TEST — adding `[[templates]]` to config.toml failed because init generated `templates = []` which conflicts with TOML array-of-tables syntax — BUG FOUND
Result: BUG FOUND
Bug: BUG-013 — Generated config.toml contains `templates = []` which prevents adding templates via documented `[[templates]]` syntax (see .docs/BUGS.md)

---

## 2026-02-23T13-21-46Z

Location: ~/wt-usage-tests/2026-02-23T13-21-46Z/
Tests performed:
- wt pin with nonexistent slot name: `wt pin nonexistent-slot-xyz` → "wt: Slot 'nonexistent-slot-xyz' not found." (exit 1) — clean error message — PASS
- wt unpin with nonexistent slot name: `wt unpin nonexistent-slot-xyz` → "wt: Slot 'nonexistent-slot-xyz' not found." (exit 1) — clean error message — PASS
- wt pin on already-pinned slot: `wt pin slate-jade-burrow` twice → first "Pinned 'slate-jade-burrow'..." (exit 0), second "Slot 'slate-jade-burrow' is already pinned." (exit 0) — idempotent, no crash — PASS
- wt unpin on already-unpinned slot: `wt unpin slate-jade-burrow` twice → first "Unpinned 'slate-jade-burrow'..." (exit 0), second "Slot 'slate-jade-burrow' is not pinned." (exit 0) — idempotent, no crash — PASS
- wt stash apply with no args from container root (not inside a slot): → "wt: Not inside a worktree slot. Specify a branch name." (exit 1) — correct per VISION §5.2.1 "defaults to the current branch" — when there is no current branch, error is clean — PASS
- wt stash show with no args from container root: → "wt: Not inside a worktree slot. Specify a branch name." (exit 1) — PASS
- wt stash drop with no args from container root (non-interactive): → "wt: Not inside a worktree slot. Specify a branch name." (exit 1) — does not hang, does not crash, clean error — PASS
- wt stash apply for a branch with stash but not checked out: `wt stash apply fix/urgent` from inside main slot → "wt: Branch 'fix/urgent' is not checked out in any slot. Run 'wt checkout fix/urgent' first." (exit 1) — correct per VISION §5.2.1 — PASS
- wt checkout to local-only branch (never pushed to remote): created branch via `git checkout -b local-only-branch` inside a slot, committed a file, then evicted it via `wt checkout main`; later `wt checkout local-only-branch` found it in the existing slot (reconciliation detected it), navigated to it; content (local-only.txt) intact — PASS
- wt init on repo with no remote configured: created local git repo with no remote, ran `wt init`; succeeded (exit 0), 5 slots created, main checked out; `wt fetch` on no-remote container printed "Fetched latest from remote." (exit 0) — no crash, essentially a no-op; `wt checkout feature/local` after creating a local branch worked correctly — PASS
- wt stash show for evicted dirty slot: `wt stash show fix/urgent` displayed correct diff with wip.txt (untracked file captured in stash) — PASS
Result: PASS

---

## 2026-02-23T21-30-00Z

Location: ~/wt-usage-tests/2026-02-23T21-30-00Z/
Tests performed:
- wt init from URL with non-main default branch ("develop"): created bare remote with `--initial-branch=develop`, pushed branches develop, feature/alpha, feature/beta, feature/gamma; ran `wt init file:///path/to/remote-repo.git` into empty directory; bare clone succeeded, fetch populated refs/remotes/origin/{develop,feature/alpha,feature/beta,feature/gamma}; BUT `refs/remotes/origin/HEAD` was NOT set (bare clone + fetch does not create it); `defaultBranch()` fell through to check `refs/remotes/origin/main` (doesn't exist), then returned "master" unconditionally; `git worktree add --detach ... origin/master` → "fatal: invalid reference: origin/master" (exit 128); init failed — BUG FOUND
Result: BUG FOUND
Bug: BUG-012 — `wt init <url>` fails when remote default branch is not "main" or "master"; `defaultBranch()` fallback blindly returns "master" instead of detecting actual remote default branch (see .docs/BUGS.md)

---

## 2026-02-23T21-00-00Z

Location: ~/wt-usage-tests/2026-02-23T20-00-00Z/
Tests performed:
- Single-slot configuration (slot_count=1): initialized 5-slot container, changed config to slot_count=1; `wt list` triggered reconciliation — 4 slots evicted, 1 remaining (vacant); `wt checkout main` into the vacant slot succeeded; created dirty state (modified file1.txt + untracked wip.txt); `wt checkout feature/alpha` evicted main with stash; `wt stash show main` confirmed both files captured; `wt checkout main` restored dirty state (wip.txt + modified file1.txt both present); pinned the only slot, `wt checkout feature/beta` → "All worktree slots are pinned. Unpin a worktree or increase the slot count to continue." (exit 1) — all correct per VISION §3.1, §5.1, §5.2, §11 — PASS
- Commands from container root (not inside a slot): `wt list` from container root displayed all 5 slots correctly (exit 0); `wt checkout feature/alpha` from container root succeeded, slot assigned (exit 0); `wt fetch` from container root succeeded (exit 0); `wt pin` from container root without slot arg → "Not inside a worktree slot. Specify a slot name." (exit 1) — all correct — PASS
- Pin a vacant slot: `wt pin light-aloft-small` on a vacant slot succeeded with "Pinned 'light-aloft-small' (branch: (vacant))" (exit 0); `wt list` showed pinned=true for vacant slot; `wt checkout feature/beta` used the pinned vacant slot (correct per VISION §11: "pins are irrelevant for vacant slots"); after checkout, slot retained pinned status; filled all 5 slots then checkout feature/delta — the pinned slot (light-aloft-small / feature/beta) was NOT evicted; LRU unpinned slot evicted instead — correct per VISION §11 — PASS
- Stash commands with zero stashes: `wt stash list` → "No saved stashes." (exit 0); `wt stash show feature/alpha` → "No stash found for branch 'feature/alpha'." (exit 1); `wt stash apply feature/alpha` → "No stash found for branch 'feature/alpha'." (exit 1) — all correct, clean error messages — PASS
- Init from existing repo with staged+unstaged+untracked dirty state: cloned remote, staged new file (staged-new.txt), modified tracked file (file1.txt), created untracked file (untracked.txt); `wt init` succeeded (exit 0), 5 slots created, main slot marked dirty; `git status` in main slot showed all 3 categories preserved: staged-new.txt still staged (Changes to be committed), file1.txt still unstaged-modified, untracked.txt present; `wt checkout main` from within the main slot was a no-op — no eviction, dirty state fully intact — correct per VISION §2.1 and §3.1 step 3 — PASS
Result: PASS

---

## 2026-02-23T19-30-00Z

Location: ~/wt-usage-tests/2026-02-23T19-30-00/
Tests performed:
- Post-checkout hook with non-zero exit code: created `.wt/hooks/post-checkout` that writes args to a file then `exit 1`; ran checkout via shell function (`eval "$(wt shell-init bash)"`); hook fired correctly ($1=slot path, $2=branch name), stderr output visible ("Hook running but will exit with error"), checkout succeeded with exit 0 despite hook failure; VISION §4.3 does not specify behavior on hook failure, non-blocking behavior is reasonable — PASS
- `wt stash apply` on archived stash: evicted feature/alpha (dirty), faked timestamp to 8 days ago, deleted remote branch, ran `wt fetch` — archival triggered correctly; then `wt stash apply feature/alpha` → "wt: Stash for 'feature/alpha' is archived. Use 'wt clean' to manage archived stashes." (exit 1) — correct, clear error message directing user to proper workflow — PASS
- Template source modification then re-sync: configured `[[templates]]` with source pointing to `.wt/templates/env.development`; ran `wt sync` — all 5 slots got `.env.development` with correct `{{WORKTREE_DIR}}` and `{{BRANCH_NAME}}` expansion; modified template source (VERSION=1.0→2.0, added NEW_SETTING=enabled); ran `wt sync` again — all 5 slots regenerated with new content (VERSION=2.0 and NEW_SETTING=enabled present in all) — correct per VISION §7.1 "always overwrite" — PASS
- Triple-slash branch name through full stash lifecycle: checked out `feature/deep/nested/path`, created dirty state (deep-wip.txt untracked, file1.txt modified), forced eviction via LRU manipulation + checkout main; stash metadata file encoded as `feature--deep--nested--path.toml` (correct per VISION §14); `wt stash show feature/deep/nested/path` displayed correct diff with all 3 files; re-checked out feature/deep/nested/path — stash auto-restored, deep-wip.txt and modified file1.txt present in new slot; stash cleaned up — full roundtrip correct — PASS
- All 5 slots occupied+dirty, checkout new branch: filled all 5 slots with branches, added real user dirty state (untracked wip file + modified file2.txt) to every slot plus template-generated .env.development; checkout feature/epsilon — LRU slot (heavy-wax-marten / fix/urgent) correctly evicted with stash creation; `wt stash show fix/urgent` confirmed all 3 dirty files captured (template .env.development, modified file2.txt, untracked user-wip-heavy-wax-marten.txt); feature/epsilon checked out successfully in the evicted slot — correct per VISION §3.1 step 4b (LRU eviction) and §5.1 (dirty state stashing) — PASS
Result: PASS

---

## 2026-02-23T18-00-00Z

Location: ~/wt-usage-tests/2026-02-23T18-00-00Z/
Tests performed:
- wt with no args outside a container (/tmp): displayed help/usage text with all commands listed; exit 0 — correct per VISION §8 ("If not [inside a managed container], it displays CLI help/usage")
- wt with no args inside worktree slot (non-TTY): ran `node /workspace/bin/wt.mjs` from inside bison-dawn-thaw slot; partial TUI render appeared briefly, then Ink crashed with "Error: Raw mode is not supported on the current process.stdin" plus a full Node.js stack trace; exit 1 — BUG FOUND
Result: BUG FOUND
Bug: BUG-011 — TUI crashes with unhandled Ink "Raw mode is not supported" error and full stack trace when stdin is not a TTY; should detect non-TTY and gracefully fall back to help output or a clean error message (see .docs/BUGS.md)

---

## 2026-02-23T17-30-00Z

Location: ~/wt-usage-tests/2026-02-23T17-30-00Z/
Tests performed:
- wt init from repo with existing local branches: cloned remote, created local branches (feature/alpha, feature/beta) before running `wt init`; init succeeded (exit 0), 5 slots created, 1 on main; bare repo at .wt/repo/ retained both local branches (feature/alpha, feature/beta) and all remote-tracking branches; `wt checkout feature/alpha` succeeded, slot assigned correctly — correct per VISION §2.1 (move existing repo into .wt/repo/)
- Slot count decrease with dirty worktrees: filled all 5 slots (main, feature/alpha-delta); created dirty state in 3 slots (main: modified file1.txt + untracked main-wip.txt; feature/alpha: untracked alpha-wip.txt; feature/beta: staged beta-staged.txt); decreased slot_count from 5 to 2 in config.toml; `wt list` triggered reconciliation — 3 LRU dirty slots evicted, 2 remaining (feature/gamma, feature/delta); `wt stash list` showed 3 active stashes (main, feature/alpha, feature/beta); `wt stash show` for each confirmed correct content preservation (modified, untracked, staged files all captured); slot directories removed — correct per VISION §10.1 (slot decrease evicts LRU) and §5.1 (dirty state stashed on eviction)
- Missing template source file: configured two [[templates]] entries — one with existing source (.env.development) and one with nonexistent source (nonexistent.yml); `wt sync` printed "wt: template source not found: <path>" once per slot (5 times) for the missing source; exit 0 (non-fatal); existing template generated correctly in all 5 slots with proper {{WORKTREE_DIR}} and {{BRANCH_NAME}} expansion; missing template's target NOT generated (correct skip); vacant slots got empty BRANCH_NAME — correct graceful handling
- Post-checkout hook with double-slash branch name: created .wt/hooks/post-checkout (writes $1 and $2 to file); ran `wt checkout feature/hook-test/deep` via shell function (eval'd shell-init bash); hook fired correctly with $1=slot absolute path, $2=feature/hook-test/deep (full branch name including slashes, not encoded); template .env.development also correctly expanded with BRANCH=feature/hook-test/deep — correct per VISION §4.3 and §7.2
Result: PASS

---

## 2026-02-23T16-30-00Z

Location: ~/wt-usage-tests/2026-02-23T16-30-00Z/
Tests performed:
- Branch encoding in stash operations (single slash): checked out feature/auth, created dirty state (staged.txt, file1.txt modified, auth-wip.txt untracked), evicted via checkout of other branches; `wt stash list` showed feature/auth correctly; stash metadata file encoded as feature--auth.toml; `wt stash show feature/auth` displayed all 3 files with correct diffs — correct per VISION §14 (encoding) and §5.2.1
- Branch encoding in stash operations (double slash): checked out feature/deep/nested, created dirty state (nested-wip.txt staged, README.md modified), evicted; stash metadata encoded as feature--deep--nested.toml; `wt stash show feature/deep/nested` showed both files; `printf 'y\n' | wt stash drop feature/deep/nested` succeeded, metadata file deleted — correct per VISION §14 (double slash → double --)
- Unpin and immediately evict: pinned all 5 slots; `wt checkout feature/deep/nested` → "All worktree slots are pinned. Unpin a worktree or increase the slot count to continue." (exit 1) — correct per VISION §11; unpinned wane-fox-fjord (fix/bug-123); `wt checkout feature/deep/nested` succeeded — wane-fox-fjord (the only unpinned slot) was correctly selected for eviction; fix/bug-123 evicted, feature/deep/nested checked in — correct per VISION §3.1 step 4b (LRU among unpinned)
- Multiple [shared] directories simultaneously: configured [shared] directories = [".config", ".tools"] with 2 files in .config/ and 1 file in .tools/; `wt sync` produced no errors; all 5 slots received correct symlinks for all 3 files across both directories; symlink targets resolved to correct canonical content; editing through one slot's symlink was visible through another slot's symlink (single canonical copy) — correct per VISION §6.2
- wt init in non-empty non-git directory: created directory with data.txt, ran `wt init` → "wt: Not a git repository. Use 'wt init <url>' to clone, or run from inside a git repository." (exit 1) — correct per VISION §15.1; also tested `wt init <url>` into directory with a dotfile → "wt: Directory is not empty. Use 'wt init' from inside an existing repository, or run from an empty directory." (exit 1) — correct per VISION §15.1
- Stash list with multiple active stashes: created dirty state in 3 slots (real user files, not just symlinks), triggered sequential evictions via checkout of feature/x, feature/y, feature/z; `wt stash list` correctly showed 2 active stashes (feature/auth and main) — the other evicted slots only had shared symlinks as dirty state (removed before stashing per BUG-007 fix), so no stash was created for them; `wt stash show` for both stashes displayed correct diffs with all user files — correct per VISION §5.1 and §5.2.1
Result: PASS

---

## 2026-02-23T15-00-00Z

Location: ~/wt-usage-tests/2026-02-23T15-00-00Z/
Tests performed:
- Self-eviction (checkout when current slot IS the LRU candidate): filled all 5 slots; from garnet-smooth-bur (main, the LRU), created dirty state (wip.txt + modified file1.txt), then ran `wt checkout feature/epsilon`; garnet-smooth-bur correctly evicted itself — stash created for main with both files, feature/epsilon checked out in same slot; `wt stash show main` confirmed both modified and untracked files preserved — correct per VISION §3.1 step 4b (LRU selection) and §5.1 (stash save)
- Nav file lifecycle via shell function: ran `bash -c 'eval "$(wt shell-init bash)"; wt checkout feature/beta'` with PATH including /workspace/bin; no nav file existed before checkout; after checkout, nav file consumed and deleted by shell function; cwd correctly changed to nettle-cairn-light (feature/beta slot) — correct per VISION §4.2 (nav file mechanism)
- Deeply nested shared directories: configured [shared] directories=[".config/deep/nested"]; created 2 canonical files (settings.json, env.local) at .wt/shared/.config/deep/nested/; ran wt sync; all 5 slots received correct symlinks at .config/deep/nested/{settings.json,env.local} with proper relative path depth (../../../../.wt/shared/...); symlink content resolved correctly — correct per VISION §6.2
- Drop archived stash (verify full cleanup): created stash for feature/epsilon, faked timestamp to 8 days ago, deleted remote branch, ran `wt fetch` — archival triggered; patch file at .wt/stashes/archive/feature--epsilon.patch + metadata at .wt/stashes/feature--epsilon.toml both present with status=archived; ran `printf 'y\n' | wt stash drop feature/epsilon`; both patch file AND metadata TOML deleted; stash list empty; archive dir empty — correct per VISION §5.5
- Multiple stash accumulation + sequential restore: evicted 3 branches (beta, zeta, main) with unique dirty state; each got independent stash with correct content per `wt stash show`; re-checked out all 3 in sequence; beta restored beta-unique.txt + modified file2.txt ✓; zeta restored zeta-work.txt + modified file2.txt ✓; main restored wip.txt + modified file1.txt ✓; all 3 stashes cleaned up after successful restore; 2 new stashes created for alpha and gamma (evicted during restoration) — correct per VISION §5.2 (restore) and §5.1 (save on eviction)
Result: PASS

---

## 2026-02-24T14-00-00Z

Location: ~/wt-usage-tests/2026-02-24T14-00-00Z/
Tests performed:
- wt fetch: ran `wt fetch` on fresh container; printed "Fetched latest from remote." exit 0; no spurious output — correct per VISION §12
- wt stash show [branch]: created dirty state (staged.txt + dirty.txt as untracked) in feature-alpha slot, forced eviction via multiple checkouts; `wt stash show feature-alpha` output a clean unified diff showing both files with correct content — correct per VISION §5.2.1
- wt unpin without slot argument (current worktree): pinned hawk-plain-delta (main) via `wt pin hawk-plain-delta`; cd into hawk-plain-delta slot; ran `wt unpin` with no args; correctly detected current slot and unpinned with message "Unpinned 'hawk-plain-delta' (branch: main). It can now be evicted via LRU." exit 0; wt list confirmed pinned=false — correct per VISION §11
- wt clean with no archived stashes: ran `wt clean` on container with no stashes; printed "No archived stashes to clean." exit 0; no crash or hang — correct graceful empty-state handling
- wt checkout nonexistent branch (no remote): ran `wt checkout totally-nonexistent-branch-xyz`; git error passed through verbatim ("error: pathspec 'totally-nonexistent-branch-xyz' did not match any file(s) known to git"); exit 1; the target slot (hawk-plain-delta) was correctly left in detached HEAD state and marked vacant; re-running `wt checkout main` succeeded and recovered the slot — correct behavior per VISION §15.3 and §3.1 error handling
- wt stash drop with piped input: `printf 'n\n' | wt stash drop feature-alpha` → "Aborted." exit 0; `printf 'y\n' | wt stash drop feature-alpha` → "Stash dropped for 'feature-alpha'." exit 0; stash list confirmed empty — correct
- wt stash drop with stdin=/dev/null (non-interactive): `wt stash drop main </dev/null` → printed prompt, then Node.js "Warning: Detected unsettled top-level await" + exit code 13; stash was NOT dropped (safe), but exit code and warning are wrong — BUG FOUND
Result: BUG FOUND
Bug: BUG-010 — `wt stash drop` crashes with exit 13 and Node.js warning when stdin is non-interactive (no data); `promptConfirm()` does not handle stdin close/EOF event (see .docs/BUGS.md)

---

## 2026-02-24T12-00-00Z

Location: ~/wt-usage-tests/2026-02-24T12-00-00Z/
Tests performed:
- wt init from repo with dirty state (staged tracked file committed, unstaged modification, untracked file): init succeeded (exit 0); dirty state preserved in the main slot (lime-muted-close); `wt list` showed slot as "dirty"; 4 vacant slots created correctly — correct behavior per VISION §2
- Shared symlink removed when checking out to a branch that git-tracks the shared file: configured [shared] directories=[".config"], created .wt/shared/.config/app.json, ran wt sync (all 5 slots got symlinks including vacant ones); then `wt checkout feature/tracked-config` (which has .config/app.json tracked in git): checkout FAILED — "error: The following untracked working tree files would be overwritten by checkout: .config/app.json" — BUG FOUND
Result: BUG FOUND
Bug: BUG-009 — `wt checkout` fails when target slot has a shared symlink that the target branch git-tracks; symlinks not removed from target slot before git checkout (see .docs/BUGS.md)

---

## 2026-02-24T11-00-00Z

Location: ~/wt-usage-tests/2026-02-24T11-00-00Z/
Tests performed:
- wt ls alias: produced identical output to wt list (5 slots, correct branch/status/pinned/last-used columns) — correct alias per VISION §9
- wt co alias: successfully checked out feature/alpha via `wt co feature/alpha`; slot assigned, wt ls confirmed — correct alias per VISION §9
- Non-executable .wt/hooks/post-checkout: created hook with chmod -x; ran wt co feature/beta; hook NOT executed (no /tmp/hook-fired.txt created), checkout succeeded exit 0 — correct per VISION §4.3 "if it exists and is executable"; made hook executable and confirmed it fires via shell function (hook writes /tmp/hook-fired.txt)
- wt stash apply with no branch argument (defaults to current branch): created dirty state in feature/alpha slot (modified + untracked files), evicted via checkout of new branch feature/zeta (stash created), re-checked out feature/alpha with --no-restore (stash preserved), then ran `wt stash apply` from inside the feature/alpha slot with NO arguments; correctly defaulted to current branch feature/alpha; applied stash and cleaned up; alpha.txt modified + untracked.txt + untracked2.txt all restored — correct per VISION §5.2.1 "defaults to the current branch"
- wt checkout with unreachable remote: set origin to file:///nonexistent/path/repo; ran wt co feature/epsilon (already in slot): git fetch error passed through verbatim ("fatal: '/nonexistent/path/repo' does not appear to be a git repository"), checkout continued, exit 0 — correct non-fatal fetch per checkout code; ran wt co feature/beta (not in slot but exists locally): fetch error printed verbatim, checkout succeeded, exit 0 — correct per VISION §15.3 (git errors pass through)
- wt sync with no [shared] section / empty directories: removed [shared] section entirely from config.toml; ran wt sync — silent exit 0; restored config with [shared] directories=[] (empty); wt sync again — silent exit 0; wt ls worked correctly — correct no-op handling per VISION §6.4
Result: PASS

---

## 2026-02-24T10-00-00Z

Location: ~/wt-usage-tests/2026-02-24T10-00-00/
Tests performed:
- Stash apply after branch rebase (conflict scenario): saved stash at base 7ac0cb1 (shared-file.txt = "base content"), force-updated local branch tip to fe86946 (shared-file.txt = "rebased content..."), re-checked out feature/rebase-test; wt detected conflict and printed "wt: Stash for feature/rebase-test produced conflicts. Resolve manually." (exit 0); shared-file.txt contained correct conflict markers (<<<<<<< Updated upstream / ======= / >>>>>>> Stashed changes); stash retained in stash list at status=active — correct per VISION §5.2
- Real file migration via wt sync: configured [shared] directories=[".config"], created real (non-symlink) .config/app.json in pool-wren-husk slot with content {"key":"migrated-value"}; ran wt sync; canonical file moved to .wt/shared/.config/app.json with original content preserved; pool-wren-husk slot got symlink -> ../../.wt/shared/.config/app.json; all 4 other slots also got correct symlinks — correct per VISION §6.2 "move it to .wt/shared/ and replace it with a symlink"
- Broken symlink cleanup via wt sync: deleted canonical .wt/shared/.config/app.json; verified all 5 slots had broken symlinks; ran wt sync; all 5 broken symlinks removed cleanly (no errors, no residual files) — correct per VISION §6.2 "If a symlink is broken (target deleted), remove it"
- Manual git worktree add in container: ran `git worktree add manual-slot feature/branch-a` directly in the bare repo; wt list showed only the 5 managed slots (ignored manual-slot), no errors, exit 0 — correct graceful handling; wt does not manage externally-added worktrees
Result: PASS

---

## 2026-02-24T09-00-00Z

Location: ~/wt-usage-tests/2026-02-24T09-00-00/
Tests performed:
- BUG-007 fix verified: shared symlinks excluded from stash on eviction; stash for feature/alpha contained only user files (alpha.txt, my-untracked.txt) — no .config/app.json symlink; stash applied cleanly with no "already exists, no checkout" error — correct
- BUG-008 fix verified: wt fetch archival produced clean output — "Warning: zstd not found. Archived stash stored uncompressed." and "Archived 1 stash(es): feature/zeta" with NO "fatal: this operation must be run in a work tree" — correct
- wt clean with actual archived stash: displayed archived stash list with branch, age, size; prompts for selection and confirmation correctly; actual deletion not confirmed (requires TTY for two sequential readline prompts — non-TTY piped input insufficient); stash archive file and metadata confirmed present before and after TTY-incomplete test
- wt stash drop on archived stash: prompt "Drop stash for 'feature/zeta'? This cannot be undone. [y/N]" appeared correctly; TTY required for confirmation
- Template {{BRANCH_NAME}} on vacant (detached) slots: wt sync generated slot-info.txt in all 5 slots; vacant slots (green-palm-talon, forest-bent-prism) correctly got branch= (empty string), not "undefined" or error; occupied slots got correct branch names — correct per templates.ts expandTemplate (slot.branch ?? "")
- Sequential eviction of all slots: evicted 3 occupied slots in sequence by checkout of lambda, mu, nu; first used 2 vacant slots, then evicted LRU occupied slot (feature/theta); 3 active stash metadata files accumulated correctly (feature/alpha, feature/eta, feature/theta) alongside existing archived feature/zeta; each stash contained correct user dirty state; no shared-symlink contamination in any stash
- Confirmed: wt clean prompts work interactively (correct behavior); piped input fails at second readline due to Node.js readline interface destroy/create pattern — expected TTY-only behavior, not a wt bug
Result: PASS

---

## 2026-02-23T24-00-00Z

Location: ~/wt-usage-tests/2026-02-23T24-00-00/
Tests performed:
- wt init twice (from inside already-initialized container): "Directory is not empty. Use 'wt init' from inside an existing repository, or run from an empty directory." (exit 1) — acceptable behavior
- Delete a slot directory (ember-quartz-trunk), run wt list: wt silently reconciled — recreated a new vacant slot (glade-spruce-reed) to maintain slot count of 5; "Preparing worktree" message printed (expected git output); list showed 5 slots correctly — correct graceful handling per VISION §3.2
- Corrupt state.toml (invalid TOML), run wt list: "Warning: .wt/state.toml is corrupted. Regenerating from git state." (stderr), state recovered from git, list showed correct slots with epoch timestamps (expected since real timestamps lost) — correct
- Stash archival: faked stash last_used_at to 8 days ago, deleted feature/alpha from remote, ran wt fetch; archival triggered; patch file written to .wt/stashes/archive/feature--alpha.patch; stash metadata updated to status=archived — correct. However: "fatal: this operation must be run in a work tree" printed to stderr before archival succeeded — BUG FOUND
Result: BUG FOUND
Bug: BUG-008 — archiveStash leaks `fatal: this operation must be run in a work tree` from git stash show called against bare repo (see .docs/BUGS.md)

---

## 2026-02-23T22:00:00Z

Location: ~/wt-usage-tests/2026-02-23T22-00-00/
Tests performed:
- zsh shell-init output: syntactically valid wt() function, uses `command wt "$@"` (BUG-003 fix present), reads /tmp/wt-nav-$$ (matching process.ppid in binary), post-checkout hook integration — correct
- fish shell-init output: syntactically valid fish function, uses `command wt $argv`, reads /tmp/wt-nav-$fish_pid — correct; zsh/fish not available in test env, static analysis only
- Non-existent branch checkout: `wt checkout nonexistent-branch-xyz` → git error passes through verbatim + "wt: Command failed with exit code 1" (exit 1) — correct per VISION §15.3
- git-tracked file wins over shared symlink: configured [shared] directories = [".config"], but branch feature/tracked-config has .config/app.json git-tracked; ran wt checkout feature/tracked-config; warning "wt: Skipping symlink for .config/app.json: file is tracked by git in branch feature/tracked-config." printed; slot has regular file (git content), NOT a symlink — correct per VISION §6.3
- Non-tracked slots get the symlink: ran wt sync; main slot got lrwxrwxrwx .config/app.json -> ../../.wt/shared/.config/app.json — correct
- wt clean with no archived stashes: "No archived stashes to clean." (exit 0) — correct
- wt pin from inside slot (no args): pinned correctly, "Pinned 'narrow-ardent-snipe' (branch: main). It will not be evicted." — correct
- wt unpin from inside slot (no args): unpinned correctly — correct
- wt pin from outside container (/tmp): "wt: Not inside a wt-managed container." (exit 1) — correct
- wt pin from container root (no slot arg): "wt: Not inside a worktree slot. Specify a slot name." (exit 1) — correct
- wt checkout --no-restore: slot checked out, auto-restore skipped, stash retained in stash list — correct (BUG-004 fix confirmed again)
- wt stash apply with tracked-file merge conflict AND shared-symlink collision: applied stash for feature/conflict-test (stash from old commit, branch at new commit); got both: (a) merge conflict markers in shared-file.txt, and (b) "already exists, no checkout" error for .config/app.json shared symlink — BUG FOUND
Result: BUG FOUND
Bug: BUG-007 — stash apply fails for shared symlinks because wt sync creates them before stash apply, causing "already exists, no checkout" error; shared symlinks should not be included in stashes (see .docs/BUGS.md)

---

## 2026-02-23T20:00:00Z

Location: ~/wt-usage-tests/2026-02-23T20-00-00/
Tests performed:
- wt init from URL (bare clone) into fresh directory: 5 slots created, 1 on main, 4 vacant — correct
- Post-checkout hook (.wt/hooks/post-checkout) with shell integration: created executable hook, ran `wt checkout feature/api` via eval'd shell function; hook called with correct args (worktree path = slot dir, branch = feature/api) — correct per VISION §4.3
- Post-checkout hook across multiple checkouts: verified hook fires on each checkout with slot-specific worktree path and branch name — correct
- Shared symlink conflict check (BUG-005 regression): configured [shared] directories = [".claude"], created .wt/shared/.claude/CLAUDE.md, ran wt sync — "error: pathspec '.claude/CLAUDE.md' did not match any file(s) known to git" still printed 5 times (once per slot)
- Root cause: dist/chunk-EHB43JQC.js still has `stdio: ["ignore", "pipe", "inherit"]` in isTracked; pnpm build was NOT run after the BUG-005 source fix was committed at 07:45:59
Result: BUG FOUND
Bug: BUG-006 — BUG-005 fix not applied to binary; dist not rebuilt after source change (see .docs/BUGS.md)

---

## 2026-02-23T16:00:00Z

Location: ~/wt-usage-tests/2026-02-23T16-00-00/
Tests performed:
- wt init from existing repo (no URL): repo moved to .wt/repo/, 5 slots created, 1 slot on main, 4 vacant — correct
- Slot count increase: changed slot_count from 5 to 7 in config.toml, ran wt list; 2 new vacant slots created automatically — correct
- Slot count decrease: changed slot_count from 7 to 4, ran wt list; 3 LRU slots removed (directories and git worktree entries cleaned up) — correct
- Slot count decrease below pinned count: pinned all 4 remaining slots, set slot_count=2, ran wt list → "wt: Cannot reduce slot count to 2: 4 worktrees are pinned. Unpin worktrees first or choose a higher count." (exit 1) — correct per VISION §10.1
- Checkout branch already in a slot: wt checkout main (already in slot widgeon-husk-flat) → exit 0, nav file pointed to correct slot, no eviction — correct per VISION §3.1 step 3
- Shared symlinks via wt sync: configured [shared] directories = [".claude"], created canonical files in .wt/shared/.claude/, ran wt sync; all 5 slots got correct symlinks pointing to canonical files — correct
- Shared symlinks on checkout: wt checkout feature/slot-count ran symlink reconciliation (step 9), symlinks created correctly in the target slot — correct
- BUG FOUND: wt sync and wt checkout print raw git error output "error: pathspec '.claude/CLAUDE.md' did not match any file(s) known to git" for every untracked shared file in every slot during the git-tracked conflict check
Result: BUG FOUND
Bug: BUG-005 — internal git stderr leaked during shared symlink conflict check (see .docs/BUGS.md)

---

## 2026-02-23T14:00:00Z

Location: ~/wt-usage-tests/2026-02-23T14-00-00/
Tests performed:
- Discovered: BUG-004 source fix was committed but dist/ was never rebuilt (pnpm build not run). Binary still had old `.option("no-restore")` code. Fixed by running `pnpm build` at start of session.
- --no-restore flag (BUG-004 fix verified post-rebuild): `wt checkout --no-restore feature/auth` succeeded (exit 0), worktree clean, stash preserved in `wt stash list` — correct
- wt stash apply (manual): `wt stash apply feature/auth` restored staged, unstaged, and untracked files; stash cleaned up on success; "Stash applied and cleaned up for 'feature/auth'." — correct (staged state becomes unstaged after apply, expected behavior of `git stash apply` without --index per VISION §5.2)
- wt stash apply on branch not in any slot: `wt stash apply feature/evict-trigger` (stash exists, branch evicted) → "wt: Branch 'feature/evict-trigger' is not checked out in any slot. Run 'wt checkout feature/evict-trigger' first." (exit 1) — correct
- wt stash apply with no stash: `wt stash apply feature/api` → "wt: No stash found for branch 'feature/api'." (exit 1) — correct
- wt fetch: ran wt fetch after adding upstream commit to feature/api; output showed "Fetched latest from remote." and remote tracking ref in bare repo updated to new commit — correct
- Template files via wt sync: configured [[templates]] in config.toml with source "templates/.env.development" (uses {{WORKTREE_DIR}} and {{BRANCH_NAME}}), ran `wt sync`; all 5 slots got correct .env.development with slot-specific WORKTREE_DIR and branch-specific BRANCH_NAME values — correct
- Template regeneration on wt checkout: checked out feature/evict-trigger into spit-lupine-cool; .env.development regenerated with BRANCH=feature/evict-trigger — correct
- Observation: generated template files (.env.development) are untracked, causing all slots to show as "dirty" in wt list — expected behavior per VISION §7.3 (user must gitignore generated files)
- LRU eviction correctness spot-checked: verified via state.toml timestamps that LRU selection correctly chose oldest slot
Result: PASS

---

## 2026-02-23T12:00:00Z

Location: ~/wt-usage-tests/2026-02-23T12-00-00/
Tests performed:
- BUG-003 fix verified: eval "$(wt shell-init bash)" then wt checkout — cwd changed correctly to slot directory, no segfault
- wt pin (by name) and wt unpin: pinned all 5 slots including a vacant one; verified pinned=true in wt list; unpinned one slot successfully
- All-slots-pinned error: with all 5 slots filled and pinned, wt checkout of new branch → "All worktree slots are pinned. Unpin a worktree or increase the slot count to continue." (exit 1) — correct per VISION.md §11
- LRU eviction with dirty state (staged + unstaged + untracked): all three file types saved in stash and shown in wt stash show — BUG-001 fix confirmed working
- wt stash list: shows branch, age, status (active), base commit correctly
- wt stash show: displays full diff of stash including untracked files
- wt stash drop: prompts for confirmation, deletes stash, wt stash list shows "No saved stashes"
- wt stash show on branch with no stash: "wt: No stash found for branch 'feature/api'." (exit 1) — correct
- Reconciliation: direct git checkout inside a slot (bypassing wt), then wt list silently updated state to show new branch — correct per VISION.md §3.2
- --no-restore flag: wt checkout --no-restore <branch> → "Unknown argument: restore" (exit 1) — BUG FOUND
Result: BUG FOUND
Bug: BUG-004 — `--no-restore` flag rejected by yargs strict mode due to boolean-negation conflict (see .docs/BUGS.md)

---

## 2026-02-23T09:00:00Z

Location: ~/wt-usage-tests/2026-02-23T09-00-00/
Tests performed:
- wt shell-init bash: output defines a syntactically valid wt() function (verified with `type wt`)
- wt checkout feature/slash-branch (branch with `/` in name): succeeded, slot assigned, wt list correct
- shell integration cwd change: eval'd shell function, then called `wt checkout` — bash segfaulted (exit 139)
- Root cause confirmed: `command -v wt` inside the shell function returns `wt` (the function name, not the binary path) because the shell function shadows the binary; `"$wt_bin" "$@"` thus calls the function recursively causing stack overflow
Result: BUG FOUND
Bug: BUG-003 — shell function infinite recursion → segfault because `command -v wt` returns function name instead of binary path (see .docs/BUGS.md)

---

## 2026-02-23T08:00:00Z

Location: ~/wt-usage-tests/2026-02-23T08-00-00/
Tests performed:
- wt init from local file:// URL (bare clone) — succeeded
- wt list from inside container: showed 1 active slot (main) + 4 vacant slots correctly
- Observed: "fatal: ref HEAD is not a symbolic ref" printed 4 times for vacant (detached HEAD) slots during reconciliation
- Bug confirmed: currentBranch() in reconcile uses stdio inherit for stderr, leaking internal git errors to terminal
Result: BUG FOUND
Bug: BUG-002 — "fatal: ref HEAD is not a symbolic ref" printed for every vacant slot on every wt command (see .docs/BUGS.md)

---

## 2026-02-23T07:05:00Z

Location: ~/wt-usage-tests/2026-02-23T10-00-00/
Tests performed:
- wt init from local repo URL (bare clone path)
- wt checkout of remote-only branches (feature/auth, feature/api, fix/bug-123, feature/db)
- wt list output format and slot assignment verification
- Stash save on LRU eviction: slot with staged + unstaged + untracked changes evicted
- Stash restore on branch re-checkout: verified staged/unstaged restored, untracked NOT restored
- git stash create --include-untracked confirmed to omit untracked files (2-parent only)
- git stash push --include-untracked confirmed to include untracked files (3-parent)
Result: BUG FOUND
Bug: BUG-001 — untracked files silently lost during slot eviction due to git stash create not supporting --include-untracked (see .docs/BUGS.md)
## 2026-02-25T10-00-00Z

Location: ~/wt-usage-tests/2026-02-25T10-00-00Z/
Tests performed:
- `wt checkout -b <new-branch>` (no start point): ran `wt checkout -b feature/new-cli` from container root; created branch from origin/main (default); exit 0; message "Created branch feature/new-cli from origin/main"; `wt list` confirmed trunk-pure-deer now holds feature/new-cli; git log in slot showed 1 commit (Initial commit, same as main tip) — correct per VISION §3.1 / Phase 2.4
- `wt checkout -b <new-branch> <start-point>`: ran `wt checkout -b feature/from-alpha origin/feature/alpha`; created branch from origin/feature/alpha; exit 0; message "Created branch feature/from-alpha from origin/feature/alpha"; slot contained alpha.txt (from feature/alpha tip) — correct
- `wt checkout -b` with existing branch name: ran `wt checkout -b feature/new-cli` again; git error "fatal: a branch named 'feature/new-cli' already exists" passed through verbatim; exit 1 — correct per VISION §15.3 (git errors pass through)
- Nav file written and cleaned up by shell function: set WT_SHELL_INTEGRATION=1; ran checkout; verified nav file written to /tmp/wt-nav-<ppid> with correct slot path and "Navigating to <slot>" message; simulated shell function (wt() wrapper with nav_file logic) in a bash script: confirmed cwd changed to correct slot after checkout AND nav file removed after read — correct per VISION §13
- `wt hooks show claude-code`: output valid Claude Code hooks JSON with PreToolUse (wt pin) and PostToolUse (wt unpin) events; exit 0 — correct per Phase 2.10 spec; `wt hooks show` (no arg) → exit 1 "requires an integration name"; `wt hooks show unknown-xyz` → exit 1 "Unknown integration 'unknown-xyz'. Supported: claude-code" — both correct
- Template creation and sync: created .wt/templates/slot-info.txt (uses {{WORKTREE_DIR}} and {{BRANCH_NAME}}), set [[templates]] source="templates/slot-info.txt" target="slot-info.txt" in config.toml (note: field is `target` not `destination`); `wt sync` exit 0; all 5 slots got correct slot-info.txt with per-slot WORKTREE_DIR and BRANCH_NAME; vacant slots got empty BRANCH_NAME — correct per VISION §7
- Template modification + re-sync: edited template (version 1 → 2, added line); `wt sync` exit 0; all 5 slots regenerated with new content (always-overwrite behavior confirmed) — correct per VISION §7.3
- Template regenerated on checkout: `wt checkout feature/new-cli` generated slot-info.txt in target slot with version 2 content — correct per VISION §7 (template generation on checkout, step 9)
Result: PASS

---

## 2026-02-25T12-00-00Z

Location: ~/wt-usage-tests/2026-02-25T12-00-00Z/
Tests performed:
- Double init (wt init, no URL) from already-initialized container root: "wt: This directory is already a wt-managed container." (exit 1) — correct; double init with URL from container root: "Directory is not empty" (exit 1) — correct
- `wt init <url>` from directory containing only a dotfile (.gitignore): "Directory is not empty" (exit 1) — correct; VISION §2.2 requires empty directory; dotfiles count as non-empty (consistent behavior)
- `wt init` (no URL) from inside a worktree slot (which has .git FILE, not directory): `wt` failed to detect that .git is a file not a directory; init proceeded, moved the .git worktree link file to .wt/repo inside the slot, created partial .wt/ structure, then failed with cryptic "ENOTDIR: git config core.bare true" — BUG FOUND
- Delete canonical shared file (.wt/shared/.config/settings.json), run `wt sync`: broken symlinks removed from all 5 slots silently (exit 0, no warning) — confirmed via Phase-3 scenario "verify broken symlinks cleaned"; consistent with VISION §6.4 (sync only creates/manages configured files; if canonical file gone, no symlink created; existing broken symlinks removed)
- Manually `git worktree add` a new directory in the container, then run `wt list`: reconcile detected the manual worktree as a new slot with epoch timestamp (LRU); adjustSlotCount evicted it immediately since state had 6 slots vs config.slot_count=5; manual worktree silently removed; `wt list` showed only 5 managed slots — behavior consistent with VISION §3.2 (silent reconcile), though surprising to user
- Drop archived stash: evicted slot created stash; faked last_used_at to 55 days ago, deleted remote branch; `wt fetch` archived stash (patch file written to .wt/stashes/archive/); `wt stash list` showed status=archived; `wt stash drop feature/shared-syms` with `y` confirmation: patch file and metadata both deleted; `wt stash list` shows "No saved stashes" — correct per VISION §5.5
Result: BUG FOUND
Bug: BUG-017 — `wt init` from inside a worktree slot corrupts the slot because the .git file (worktree link) is not distinguished from a .git/ directory (see .docs/BUGS.md)

---

## 2026-02-25T05-57-32Z

Location: ~/wt-usage-tests/2026-02-25T05-57-32Z/
Tests performed:
- Phase 2.2 init feedback: `wt init file://<url>` printed full slot summary (all 5 slot names with active/vacant status, which slot has the active branch) and shell integration hint (eval lines for bash/zsh/fish); exit 0 — correct per Phase 2.2 spec
- Phase 2.3 checkout feedback: (a) simple checkout into vacant slot → "Checked out <branch> in <slot>" message confirmed; (b) eviction with dirty state → "Checked out <branch> in <slot>" + "Evicted <old-branch> from <slot> (dirty state stashed)" both printed; (c) re-checkout of evicted branch → "Checked out <branch> in <slot>" + "Evicted <old-branch> from <slot>" + "Restored stash from just now" all printed; stash list empty after restore; wip.txt confirmed present in new slot — correct per Phase 2.3 spec
- BUG-009 fix verification: configured [shared] directories=[".config"] with canonical .wt/shared/.config/app.json; ran wt sync — vacant slots got symlinks .config/app.json (main branch has no .config tracked, so symlink created correctly); then `wt checkout feature/tracked-config` (which git-tracks .config/app.json) targeted slot chill-root-violet (which had the symlink); message "Skipping symlink for .config/app.json: file is tracked by git in branch feature/tracked-config." printed; checkout succeeded; chill-root-violet now has regular file (git-tracked content `{"feature":"tracked"}`) not a symlink — BUG-009 fix confirmed correct
- BUG-010 fix regression: `wt stash drop feature/e </dev/null` still crashes with exit 13 and "Warning: Detected unsettled top-level await"; stash NOT dropped (safe); root cause: `promptConfirm()` in stash.ts listens for "close" event on process.stdin, but Node.js stdin connected to /dev/null emits "end" (not "close") — confirmed via `node -e "stdin.on('end',()=>log('end'));stdin.on('close',()=>log('close'))" </dev/null` which only prints "end"; fix needs "end" event listener — BUG FOUND
Result: BUG FOUND
Bug: BUG-018 — `wt stash drop` with stdin=/dev/null still crashes (exit 13): `promptConfirm` fix incomplete, listens for "close" but stdin emits "end" (see .docs/BUGS.md)

---

